# Directory API v1 - Cursor Rules

## General Go Development Guidelines

### Code Quality & Constants
- **NO hardcoded strings in code** - All string literals must be defined as package-local constants
- Use meaningful constant names that clearly express intent
- Group related constants together with clear documentation
- Define constants within the same package where they are used
- Use camelCase for unexported constants (e.g., `errorNotImplemented`)

### Examples of Required Constants Usage
```go
// ❌ BAD - Hardcoded strings
return errors.New("not implemented")
slog.ErrorContext(ctx, "failed to run", "error", err)
if containsOperation(resource.Operations, "Read") {

// ✅ GOOD - Use package-local constants
const (
    errorNotImplemented = "not implemented"
    errorFailedToRun    = "failed to run"
    logKeyError         = "error"
)

return errors.New(errorNotImplemented)
slog.ErrorContext(ctx, errorFailedToRun, logKeyError, err)
if containsOperation(resource.Operations, OperationRead) {
```

### String Categories Requiring Constants
1. **Error Messages**: All error strings must use package-local constants
2. **Log Messages**: All log message keys and values must use package-local constants
3. **CRUD Operations**: "Create", "Read", "Update", "Delete" → use local Operation* constants
4. **Field Types**: "UUID", "String", "Int", "Bool" → define as needed per package
5. **HTTP Methods**: "GET", "POST", etc. → define as needed per package
6. **Content Types**: "application/json" → define as needed per package
7. **Field Modifiers**: "array", "nullable" → define as needed per package

### Exception for Test Files
Test files (files ending in `_test.go`) may contain hardcoded strings for test data, but should still use constants for:
- Repeated test values
- Error messages being tested
- Configuration values

### Adding New Constants
When adding new functionality:
1. Define constants within the same package where they are used
2. Use clear, descriptive names following Go naming conventions
3. Group related constants together in const blocks
4. Use camelCase for unexported constants
5. Add documentation comments for const blocks when needed

### Code Review Checklist
Before submitting code:
- [ ] No hardcoded strings in production code (except test data)
- [ ] All constants defined as package-local constants
- [ ] Constants grouped logically in const blocks
- [ ] Clear and descriptive constant names used
- [ ] Proper camelCase naming for unexported constants

This ensures maintainable, consistent code that's easy to update and internationalize if needed.

## Go Code Formatting Rules

### Automatic Formatting
- **ALWAYS run `gofmt -s -w .` after making any Go code changes**
- All Go code MUST follow standard Go formatting conventions
- Use Go's standard formatting (gofmt) - no custom formatting rules
- Ensure proper import organization and grouping

### Formatting Requirements
- Use tabs for indentation (Go standard)
- Keep line lengths reasonable (prefer under 100 characters when possible)
- Follow Go's standard comment formatting
- Use proper spacing around operators and after commas
- Organize imports in standard groups: standard library, third party, local

### Before Committing
- [ ] Run `gofmt -s -w .` to format all Go files
- [ ] Verify no linting errors with proper formatting
- [ ] Check that all string literals use package-local constants
- [ ] Ensure consistent code style throughout

### Cursor-Specific Instructions
When editing Go code:
1. **IMMEDIATELY** after any Go code modification, run gofmt formatting
2. Follow the repository's constant usage rules (no hardcoded strings)
3. Maintain consistent indentation and spacing
4. Keep import statements properly organized
5. Ensure all functions and types have proper documentation comments

## Build Artifacts and Binary Files

### Binary File Management
- **NEVER commit binary files or build artifacts to the repository**
- Build artifacts include but are not limited to:
  - Compiled Go binaries (e.g., `publicapis-gen`, executable files)
  - Coverage files (`coverage.out`, `coverage.html`) - these are temporary test artifacts
  - Any files generated by `go build` or similar build commands
- Always clean up build artifacts after testing or building

### Build Process
- Use `go build .` for local development and testing only
- Binaries should be built in CI/CD pipelines for releases
- If you accidentally commit a binary file, remove it immediately

### File Exclusions
Files that should NEVER be committed:
- Any executable files without extensions (typically Go binaries)
- `.exe` files (Windows binaries)
- Coverage output files (`*.out`, `coverage.html`)
- Temporary build files and artifacts