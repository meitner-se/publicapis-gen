package openapigen

import (
	"bytes"
	"errors"
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"

	"github.com/meitner-se/publicapis-gen/specification"
	"github.com/pb33f/libopenapi/datamodel/high/base"
	v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
	"github.com/pb33f/libopenapi/orderedmap"
	yaml "gopkg.in/yaml.v3"
)

// Error constants
const (
	errorInvalidService  = "invalid service: service cannot be nil"
	errorInvalidDocument = "invalid document: document cannot be nil"
)

// HTTP Status Code constants
const (
	httpStatus400 = "400"
	httpStatus401 = "401"
	httpStatus403 = "403"
	httpStatus404 = "404"
	httpStatus409 = "409"
	httpStatus422 = "422"
	httpStatus429 = "429"
	httpStatus500 = "500"
)

// OpenAPI version constants
const (
	defaultOpenAPIVersion = "3.1.0"
	defaultServiceVersion = "1.0.0"
)

// API generation constants
const (
	apiTitleSuffix        = " API"
	defaultAPIDescription = "Generated API documentation"
)

// Content type constants
const (
	contentTypeJSON = "application/json"
)

// Standard response descriptions
const (
	requestBodyDescription = "Request body"
	successDescription     = "Successful response"
)

// Autogenerated response description templates
const (
	autoResponseCreateTemplate = "Response for %s Create operation - returns the created %s"
	autoResponseUpdateTemplate = "Response for %s Update operation - returns the updated %s"
	autoResponseDeleteTemplate = "Response for %s Delete operation - confirms successful deletion"
	autoResponseGetTemplate    = "Response for %s Get operation - returns the requested %s"
	autoResponseListTemplate   = "Response for %s List operation - returns a paginated list of %s"
	autoResponseSearchTemplate = "Response for %s Search operation - returns filtered %s results"
)

// Autogenerated error response description templates
const (
	autoErrorBadRequestTemplate    = "Bad Request error for %s %s operation - request contains invalid parameters"
	autoErrorUnauthorizedTemplate  = "Unauthorized error for %s %s operation - authentication required"
	autoErrorForbiddenTemplate     = "Forbidden error for %s %s operation - insufficient permissions"
	autoErrorNotFoundTemplate      = "Not Found error for %s %s operation - resource does not exist"
	autoErrorConflictTemplate      = "Conflict error for %s %s operation - request conflicts with current state"
	autoErrorUnprocessableTemplate = "Validation error for %s %s operation - request data failed validation"
	autoErrorRateLimitTemplate     = "Rate Limit error for %s %s operation - too many requests"
	autoErrorInternalTemplate      = "Internal Server error for %s %s operation - unexpected server error"
)

// Schema reference format constants
const (
	schemaReferencePrefix       = "#/components/schemas/"
	responseBodyReferencePrefix = "#/components/responses/"
	requestBodyReferencePrefix  = "#/components/requestBodies/"
)

// Server description template
const (
	serverDescriptionTemplate = "%s server"
)

// Error response descriptions
const (
	badRequestDescription    = "Bad Request - The request was malformed or contained invalid parameters"
	unauthorizedDescription  = "Unauthorized - The request is missing valid authentication credentials"
	notFoundDescription      = "Not Found - The requested resource does not exist"
	internalErrorDescription = "Internal Server Error - An unexpected server error occurred"
)

// Error code names
const (
	errorCodeBadRequest          = "BadRequest"
	errorCodeUnauthorized        = "Unauthorized"
	errorCodeForbidden           = "Forbidden"
	errorCodeNotFound            = "NotFound"
	errorCodeConflict            = "Conflict"
	errorCodeUnprocessableEntity = "UnprocessableEntity"
	errorCodeRateLimited         = "RateLimited"
	errorCodeInternal            = "Internal"
)

// Schema types
const (
	schemaTypeString  = "string"
	schemaTypeInteger = "integer"
	schemaTypeBoolean = "boolean"
	schemaTypeArray   = "array"
	schemaTypeObject  = "object"
)

// YAML tag constants
const (
	tagString = "!!str"
)

// Schema formats
const (
	schemaFormatUUID     = "uuid"
	schemaFormatDate     = "date"
	schemaFormatDateTime = "date-time"
)

// Speakeasy retry configuration constants
const (
	speakeasyRetriesExtension = "x-speakeasy-retries"
)

// Speakeasy timeout configuration constants
const (
	speakeasyTimeoutExtension = "x-speakeasy-timeout"
	defaultTimeoutMs          = 30000 // 30 seconds in milliseconds
)

// Speakeasy server ID extension constants
const (
	speakeasyServerIdExtension = "x-speakeasy-server-id"
)

// Speakeasy operation naming extension constants
const (
	speakeasyGroupExtension        = "x-speakeasy-group"
	speakeasyNameOverrideExtension = "x-speakeasy-name-override"
)

// Retry configuration field names
const (
	retryFieldStrategy              = "strategy"
	retryFieldBackoff               = "backoff"
	retryFieldInitialInterval       = "initialInterval"
	retryFieldMaxInterval           = "maxInterval"
	retryFieldMaxElapsedTime        = "maxElapsedTime"
	retryFieldExponent              = "exponent"
	retryFieldStatusCodes           = "statusCodes"
	retryFieldRetryConnectionErrors = "retryConnectionErrors"
)

// Speakeasy pagination configuration constants
const (
	speakeasyPaginationExtension  = "x-speakeasy-pagination"
	speakeasyPaginationType       = "offsetLimit"
	speakeasyOffsetParamName      = "offset"
	speakeasyLimitParamName       = "limit"
	speakeasyResultsFieldPath     = "$.data.resultArray"
	speakeasyPaginationInputsIn   = "parameters"
	speakeasyPaginationOffsetType = "offset"
	speakeasyPaginationLimitType  = "limit"
	speakeasyDataFieldName        = "Data" // Still used in isPaginatedOperation
)

// List endpoint parameter names (should match specification package constants)
const (
	listLimitParamName  = "Limit"
	listOffsetParamName = "Offset"
)

// Object and field names
const (
	errorObjectName         = "Error"
	messageFieldName        = "message"
	codeFieldName           = "code"
	requestIDFieldName      = "requestID"
	errorFieldName          = "error"
	errorFieldsFieldName    = "errorFields"
	errorCodeEnumName       = "ErrorCode"
	requestBodySuffix       = "RequestBody"
	responseBodySuffix      = "ResponseBody"
	errorResponseBodyPrefix = "Error"
	searchEndpointNameValue = "Search"
)

// Security scheme constants
const (
	securityTypeHTTP   = "http"
	securityTypeAPIKey = "apiKey"
)

// generator handles OpenAPI 3.1 specification generation from specification.Service.
type generator struct {
	// Version specifies the OpenAPI version to generate (default: "3.1.0")
	Version string

	// Title specifies the API title (defaults to service name if not set)
	Title string

	// Description specifies the API description
	Description string

	// ServerURL specifies the base server URL for the API
	ServerURL string
}

// newGenerator creates a new OpenAPI generator with default settings.
func newGenerator() *generator {
	return &generator{
		Version: defaultOpenAPIVersion,
	}
}

// generateFromService generates an OpenAPI 3.1 document from a specification.Service.
func (g *generator) generateFromService(service *specification.Service) (*v3.Document, error) {
	if service == nil {
		return nil, errors.New(errorInvalidService)
	}

	// Build document using native libopenapi v3 types
	return g.buildV3Document(service), nil
}

// addSpeakeasyRetryExtension adds Speakeasy retry configuration extension to the OpenAPI document.
func (g *generator) addSpeakeasyRetryExtension(document *v3.Document, service *specification.Service) {
	// Initialize extensions map if it doesn't exist
	if document.Extensions == nil {
		document.Extensions = orderedmap.New[string, *yaml.Node]()
	}

	// Get retry configuration from service with defaults applied
	retryConfig := service.GetRetryConfigurationWithDefaults()

	// Convert the retry configuration to a YAML node
	retryNode := &yaml.Node{
		Kind: yaml.MappingNode,
	}

	// Create nodes for the retry configuration
	strategyKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldStrategy}
	strategyValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryConfig.Strategy}

	backoffKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldBackoff}
	backoffValueNode := &yaml.Node{Kind: yaml.MappingNode, Tag: "!!map"}

	// Backoff sub-nodes
	initialIntervalKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldInitialInterval}
	initialIntervalValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: strconv.Itoa(retryConfig.Backoff.InitialInterval)}
	maxIntervalKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldMaxInterval}
	maxIntervalValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: strconv.Itoa(retryConfig.Backoff.MaxInterval)}
	maxElapsedTimeKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldMaxElapsedTime}
	maxElapsedTimeValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: strconv.Itoa(retryConfig.Backoff.MaxElapsedTime)}
	exponentKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldExponent}
	exponentValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%g", retryConfig.Backoff.Exponent)}

	backoffValueNode.Content = []*yaml.Node{
		initialIntervalKeyNode, initialIntervalValueNode,
		maxIntervalKeyNode, maxIntervalValueNode,
		maxElapsedTimeKeyNode, maxElapsedTimeValueNode,
		exponentKeyNode, exponentValueNode,
	}

	statusCodesKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldStatusCodes}
	statusCodesValueNode := &yaml.Node{Kind: yaml.SequenceNode, Tag: "!!seq"}
	statusCodesNodes := make([]*yaml.Node, len(retryConfig.StatusCodes))
	for i, statusCode := range retryConfig.StatusCodes {
		statusCodesNodes[i] = &yaml.Node{
			Kind:  yaml.ScalarNode,
			Value: statusCode,
			Tag:   "!!str", // Ensure this is treated as a string
		}
	}
	statusCodesValueNode.Content = statusCodesNodes

	connectionErrorsKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: retryFieldRetryConnectionErrors}
	connectionErrorsValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: strconv.FormatBool(retryConfig.RetryConnectionErrors)}

	// Assemble the main retry configuration node
	retryNode.Content = []*yaml.Node{
		strategyKeyNode, strategyValueNode,
		backoffKeyNode, backoffValueNode,
		statusCodesKeyNode, statusCodesValueNode,
		connectionErrorsKeyNode, connectionErrorsValueNode,
	}

	// Add the extension to the document
	document.Extensions.Set(speakeasyRetriesExtension, retryNode)
}

// addSpeakeasyTimeoutExtension adds Speakeasy timeout configuration extension to the OpenAPI document.
func (g *generator) addSpeakeasyTimeoutExtension(document *v3.Document, service *specification.Service) {
	// Initialize extensions map if it doesn't exist
	if document.Extensions == nil {
		document.Extensions = orderedmap.New[string, *yaml.Node]()
	}

	// Determine timeout value from service configuration or use default
	timeoutMs := defaultTimeoutMs
	if service.Timeout != nil && service.Timeout.Timeout > 0 {
		timeoutMs = service.Timeout.Timeout
	}

	// Create a YAML node for the timeout value (in milliseconds)
	timeoutNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Value: strconv.Itoa(timeoutMs),
	}

	// Add the extension to the document
	document.Extensions.Set(speakeasyTimeoutExtension, timeoutNode)
}

// addSpeakeasyPaginationExtension adds Speakeasy pagination configuration extension to an operation.
func (g *generator) addSpeakeasyPaginationExtension(operation *v3.Operation) {
	// Initialize extensions map if it doesn't exist
	if operation.Extensions == nil {
		operation.Extensions = orderedmap.New[string, *yaml.Node]()
	}

	// Convert the pagination configuration to a YAML node
	paginationNode := &yaml.Node{
		Kind: yaml.MappingNode,
	}

	// Create nodes for the pagination configuration
	typeKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "type"}
	typeValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: speakeasyPaginationType}

	// Create the inputs array
	inputsKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "inputs"}
	inputsArrayNode := &yaml.Node{Kind: yaml.SequenceNode, Tag: "!!seq"}

	// Create Field objects to get proper JSON tag names
	offsetField := specification.Field{Name: listOffsetParamName}
	limitField := specification.Field{Name: listLimitParamName}

	// Create offset input object
	offsetInputNode := &yaml.Node{Kind: yaml.MappingNode, Tag: "!!map"}
	offsetNameKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "name"}
	offsetNameValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: offsetField.TagJSON()}
	offsetInKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "in"}
	offsetInValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: speakeasyPaginationInputsIn}
	offsetTypeKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "type"}
	offsetTypeValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: speakeasyPaginationOffsetType}
	offsetInputNode.Content = []*yaml.Node{
		offsetNameKeyNode, offsetNameValueNode,
		offsetInKeyNode, offsetInValueNode,
		offsetTypeKeyNode, offsetTypeValueNode,
	}

	// Create limit input object
	limitInputNode := &yaml.Node{Kind: yaml.MappingNode, Tag: "!!map"}
	limitNameKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "name"}
	limitNameValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: limitField.TagJSON()}
	limitInKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "in"}
	limitInValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: speakeasyPaginationInputsIn}
	limitTypeKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "type"}
	limitTypeValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: speakeasyPaginationLimitType}
	limitInputNode.Content = []*yaml.Node{
		limitNameKeyNode, limitNameValueNode,
		limitInKeyNode, limitInValueNode,
		limitTypeKeyNode, limitTypeValueNode,
	}

	// Add input objects to inputs array
	inputsArrayNode.Content = []*yaml.Node{offsetInputNode, limitInputNode}

	// Create the outputs object
	outputsKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "outputs"}
	outputsObjectNode := &yaml.Node{Kind: yaml.MappingNode, Tag: "!!map"}
	resultsKeyNode := &yaml.Node{Kind: yaml.ScalarNode, Value: "results"}
	resultsValueNode := &yaml.Node{Kind: yaml.ScalarNode, Value: speakeasyResultsFieldPath}
	outputsObjectNode.Content = []*yaml.Node{
		resultsKeyNode, resultsValueNode,
	}

	// Assemble the main pagination configuration node
	paginationNode.Content = []*yaml.Node{
		typeKeyNode, typeValueNode,
		inputsKeyNode, inputsArrayNode,
		outputsKeyNode, outputsObjectNode,
	}

	// Add the extension to the operation
	operation.Extensions.Set(speakeasyPaginationExtension, paginationNode)
}

// addSpeakeasyOperationNamingExtensions adds Speakeasy operation naming extensions to an operation.
func (g *generator) addSpeakeasyOperationNamingExtensions(operation *v3.Operation, endpoint specification.Endpoint, resource specification.Resource) {
	// Initialize extensions map if it doesn't exist
	if operation.Extensions == nil {
		operation.Extensions = orderedmap.New[string, *yaml.Node]()
	}

	// Add x-speakeasy-group extension (resource name in camelCase and plural)
	groupValue := specification.CamelCase(resource.GetPluralName())
	groupNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Value: groupValue,
	}
	operation.Extensions.Set(speakeasyGroupExtension, groupNode)

	// Add x-speakeasy-name-override extension (method name in camelCase)
	nameOverrideValue := specification.CamelCase(endpoint.Name)
	nameOverrideNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Value: nameOverrideValue,
	}
	operation.Extensions.Set(speakeasyNameOverrideExtension, nameOverrideNode)
}

// isPaginatedOperation determines if an endpoint represents a paginated operation
// by checking for the presence of limit/offset query parameters and data/pagination response fields.
func (g *generator) isPaginatedOperation(endpoint specification.Endpoint) bool {
	hasLimitParam := false
	hasOffsetParam := false

	// Check query parameters for limit and offset
	// Check based on the JSON tag name (camelCase) which is what appears in the actual API
	for _, param := range endpoint.Request.QueryParams {
		paramTagJSON := param.TagJSON()
		if paramTagJSON == speakeasyLimitParamName {
			hasLimitParam = true
		}
		if paramTagJSON == speakeasyOffsetParamName {
			hasOffsetParam = true
		}
	}

	// Must have both limit and offset parameters
	if !hasLimitParam || !hasOffsetParam {
		return false
	}

	hasDataField := false
	hasPaginationField := false

	// Check response body fields for data and pagination
	for _, field := range endpoint.Response.BodyFields {
		if field.Name == speakeasyDataFieldName {
			hasDataField = true
		}
		if field.Name == "Pagination" || field.Name == "pagination" {
			hasPaginationField = true
		}
	}

	// Must have both data and pagination fields in response
	return hasDataField && hasPaginationField
}

// buildV3Document creates a v3.Document using native libopenapi types.
func (g *generator) buildV3Document(service *specification.Service) *v3.Document {
	// Create document title
	title := g.Title
	if title == "" {
		title = service.Name
	}

	// Create Info section
	version := service.Version
	if version == "" {
		version = defaultServiceVersion // Default version if not specified
	}

	info := &base.Info{
		Title:       title,
		Description: g.Description,
		Version:     version,
	}

	// Add contact information if available in the service
	if service.Contact != nil {
		contact := &base.Contact{}
		if service.Contact.Name != "" {
			contact.Name = service.Contact.Name
		}
		if service.Contact.URL != "" {
			contact.URL = service.Contact.URL
		}
		if service.Contact.Email != "" {
			contact.Email = service.Contact.Email
		}
		// Only set contact if at least one field is provided
		if service.Contact.Name != "" || service.Contact.URL != "" || service.Contact.Email != "" {
			info.Contact = contact
		}
	}

	// Add license information if available in the service
	if service.License != nil && service.License.Name != "" {
		license := &base.License{
			Name: service.License.Name,
		}
		if service.License.URL != "" {
			license.URL = service.License.URL
		}
		if service.License.Identifier != "" {
			license.Identifier = service.License.Identifier
		}
		info.License = license
	}

	// Create Document
	document := &v3.Document{
		Version: g.Version,
		Info:    info,
	}

	// Add Speakeasy retry configuration as extension
	g.addSpeakeasyRetryExtension(document, service)

	// Add Speakeasy timeout configuration as extension
	g.addSpeakeasyTimeoutExtension(document, service)

	// Add servers from service specification
	if len(service.Servers) > 0 {
		servers := make([]*v3.Server, len(service.Servers))
		for i, server := range service.Servers {
			openAPIServer := &v3.Server{
				URL:         server.URL,
				Description: server.Description,
			}

			// Add x-speakeasy-server-id extension if server has an ID
			if server.ID != "" {
				if openAPIServer.Extensions == nil {
					openAPIServer.Extensions = orderedmap.New[string, *yaml.Node]()
				}
				serverIdNode := &yaml.Node{
					Kind:  yaml.ScalarNode,
					Value: server.ID,
				}
				openAPIServer.Extensions.Set(speakeasyServerIdExtension, serverIdNode)
			}

			servers[i] = openAPIServer
		}
		document.Servers = servers
	} else if g.ServerURL != "" {
		// Fallback to generator's ServerURL for backwards compatibility
		servers := []*v3.Server{
			{
				URL:         g.ServerURL,
				Description: fmt.Sprintf(serverDescriptionTemplate, title),
			},
		}
		document.Servers = servers
	}

	// Create Components
	components := &v3.Components{
		Schemas:         orderedmap.New[string, *base.SchemaProxy](),
		RequestBodies:   orderedmap.New[string, *v3.RequestBody](),
		Responses:       orderedmap.New[string, *v3.Response](),
		SecuritySchemes: orderedmap.New[string, *v3.SecurityScheme](),
	}

	// Add enums to components
	for _, enum := range service.Enums {
		schema := g.createEnumSchema(enum)
		proxy := base.CreateSchemaProxy(schema)
		components.Schemas.Set(enum.Name, proxy)
	}

	// Add objects to components
	for _, obj := range service.Objects {
		schema := g.createObjectSchema(obj, service)
		proxy := base.CreateSchemaProxy(schema)
		components.Schemas.Set(obj.Name, proxy)
	}

	// Add request bodies to components
	g.addRequestBodiesToComponents(components, service)

	// Add response bodies to components
	g.addResponseBodiesToComponents(components, service)

	// Add security schemes to components
	g.addSecuritySchemesToComponents(components, service)

	document.Components = components

	// Add security requirements to document
	g.addSecurityToDocument(document, service)

	// Create Paths
	paths := orderedmap.New[string, *v3.PathItem]()
	for _, resource := range service.Resources {
		g.addResourceToPaths(resource, paths, service)
	}
	document.Paths = &v3.Paths{
		PathItems: paths,
	}

	// Create tags from resources
	document.Tags = g.createTagsFromResources(service)

	return document
}

// createTagsFromResources creates a tags array from service resources for top-level document organization.
func (g *generator) createTagsFromResources(service *specification.Service) []*base.Tag {
	if len(service.Resources) == 0 {
		return nil
	}

	tags := make([]*base.Tag, len(service.Resources))
	for i, resource := range service.Resources {
		tags[i] = &base.Tag{
			Name:        resource.Name,
			Description: resource.Description,
		}
	}

	return tags
}

// createEnumSchema creates a base.Schema for an enum using native types.
func (g *generator) createEnumSchema(enum specification.Enum) *base.Schema {
	schema := &base.Schema{
		Type:        []string{schemaTypeString},
		Description: enum.Description,
	}

	// Add enum values
	enumValues := make([]*yaml.Node, len(enum.Values))
	for i, value := range enum.Values {
		node := &yaml.Node{
			Kind:  yaml.ScalarNode,
			Value: value.Name,
			Tag:   tagString, // Ensure enum values are treated as strings
		}
		enumValues[i] = node
	}
	schema.Enum = enumValues

	return schema
}

// createObjectSchema creates a base.Schema for an object using native types.
func (g *generator) createObjectSchema(obj specification.Object, service *specification.Service) *base.Schema {
	schema := &base.Schema{
		Type:        []string{schemaTypeObject},
		Description: obj.Description,
		Properties:  orderedmap.New[string, *base.SchemaProxy](),
	}

	requiredFields := []string{}
	for _, field := range obj.Fields {
		fieldSchema := g.createFieldSchema(field, service)
		proxy := base.CreateSchemaProxy(fieldSchema)
		schema.Properties.Set(field.TagJSON(), proxy)

		if field.IsRequired(service) {
			requiredFields = append(requiredFields, field.TagJSON())
		}
	}

	if len(requiredFields) > 0 {
		schema.Required = requiredFields
	}

	return schema
}

// createFieldSchema creates a base.Schema for a field using native types.
func (g *generator) createFieldSchema(field specification.Field, service *specification.Service) *base.Schema {
	var schema *base.Schema

	// Handle array modifier
	if field.IsArray() {
		schema = &base.Schema{
			Type:        []string{schemaTypeArray},
			Description: field.Description,
		}

		itemSchema := g.getTypeSchema(field.Type, service)
		schema.Items = &base.DynamicValue[*base.SchemaProxy, bool]{
			N: 0, // Single schema (not boolean)
			A: base.CreateSchemaProxy(itemSchema),
		}
	} else {
		schema = g.getTypeSchema(field.Type, service)
		schema.Description = field.Description
	}

	// Handle nullable modifier
	if field.IsNullable() {
		// Use the Nullable field instead of appending "null" to type array
		nullable := true
		schema.Nullable = &nullable
	}

	// Add default value if present
	if field.Default != "" {
		defaultNode := &yaml.Node{
			Kind:  yaml.ScalarNode,
			Value: field.Default,
		}
		schema.Default = defaultNode
	}

	// Add example if present
	if field.Example != "" {
		exampleNode := g.createTypedExampleNode(field.Type, field.Example)

		// Handle array modifier - wrap the value in an array if needed
		if field.IsArray() {
			arrayNode := &yaml.Node{
				Kind: yaml.SequenceNode,
				Tag:  "!!seq",
			}
			arrayNode.Content = append(arrayNode.Content, exampleNode)
			exampleNode = arrayNode
		}

		// Create examples array - include the regular example
		examples := []*yaml.Node{exampleNode}

		// If the field is nullable, add null as an additional example
		if field.IsNullable() {
			nullNode := g.createNullExampleNode()
			examples = append(examples, nullNode)
		}

		schema.Examples = examples
	} else if field.IsArray() && service.HasObject(field.Type) {
		// Generate example array from object definition when no explicit example is provided
		if obj := service.GetObject(field.Type); obj != nil {
			visited := make(map[string]bool)
			if objectExample := g.generateObjectExampleWithVisited(*obj, service, visited); objectExample != nil {
				arrayNode := &yaml.Node{
					Kind: yaml.SequenceNode,
					Tag:  "!!seq",
				}
				arrayNode.Content = append(arrayNode.Content, objectExample)

				examples := []*yaml.Node{arrayNode}

				// If the field is nullable, add null as an additional example
				if field.IsNullable() {
					nullNode := g.createNullExampleNode()
					examples = append(examples, nullNode)
				}

				schema.Examples = examples
			}
		}
	} else if service.HasObject(field.Type) {
		// Generate example from object definition when no explicit example is provided
		if obj := service.GetObject(field.Type); obj != nil {
			visited := make(map[string]bool)
			if objectExample := g.generateObjectExampleWithVisited(*obj, service, visited); objectExample != nil {
				examples := []*yaml.Node{objectExample}

				// If the field is nullable, add null as an additional example
				if field.IsNullable() {
					nullNode := g.createNullExampleNode()
					examples = append(examples, nullNode)
				}

				schema.Examples = examples
			}
		}
	}

	return schema
}

// createParameterSchema creates a base.Schema for a field used in parameters, without description to avoid duplication.
func (g *generator) createParameterSchema(field specification.Field, service *specification.Service) *base.Schema {
	var schema *base.Schema

	// Handle array modifier
	if field.IsArray() {
		schema = &base.Schema{
			Type: []string{schemaTypeArray},
			// Note: No description here to avoid duplication with parameter description
		}

		itemSchema := g.getTypeSchema(field.Type, service)
		schema.Items = &base.DynamicValue[*base.SchemaProxy, bool]{
			N: 0, // Single schema (not boolean)
			A: base.CreateSchemaProxy(itemSchema),
		}
	} else {
		schema = g.getTypeSchema(field.Type, service)
		// Note: No description set here to avoid duplication with parameter description
	}

	// Handle nullable modifier
	if field.IsNullable() {
		// Use the Nullable field instead of appending "null" to type array
		nullable := true
		schema.Nullable = &nullable
	}

	// Add default value if present
	if field.Default != "" {
		defaultNode := &yaml.Node{
			Kind:  yaml.ScalarNode,
			Value: field.Default,
		}
		schema.Default = defaultNode
	}

	// Add example if present
	if field.Example != "" {
		exampleNode := g.createTypedExampleNode(field.Type, field.Example)

		// Handle array modifier - wrap the value in an array if needed
		if field.IsArray() {
			arrayNode := &yaml.Node{
				Kind: yaml.SequenceNode,
				Tag:  "!!seq",
			}
			arrayNode.Content = append(arrayNode.Content, exampleNode)
			exampleNode = arrayNode
		}

		// Create examples array - include the regular example
		examples := []*yaml.Node{exampleNode}

		// If the field is nullable, add null as an additional example
		if field.IsNullable() {
			nullNode := g.createNullExampleNode()
			examples = append(examples, nullNode)
		}

		schema.Examples = examples
	}

	return schema
}

// getTypeSchema returns a base.Schema for the given field type.
func (g *generator) getTypeSchema(fieldType string, service *specification.Service) *base.Schema {
	switch fieldType {
	case specification.FieldTypeString:
		return &base.Schema{Type: []string{schemaTypeString}}
	case specification.FieldTypeInt:
		return &base.Schema{Type: []string{schemaTypeInteger}}
	case specification.FieldTypeBool:
		return &base.Schema{Type: []string{schemaTypeBoolean}}
	case specification.FieldTypeUUID:
		return &base.Schema{
			Type:   []string{schemaTypeString},
			Format: schemaFormatUUID,
		}
	case specification.FieldTypeDate:
		return &base.Schema{
			Type:   []string{schemaTypeString},
			Format: schemaFormatDate,
		}
	case specification.FieldTypeTimestamp:
		return &base.Schema{
			Type:   []string{schemaTypeString},
			Format: schemaFormatDateTime,
		}
	default:
		// Check if it's a custom object or enum
		if service.HasObject(fieldType) || service.HasEnum(fieldType) {
			// Create a proper $ref schema reference using allOf
			refString := schemaReferencePrefix + fieldType
			refProxy := base.CreateSchemaProxyRef(refString)

			// Return a schema with AllOf that contains the reference
			return &base.Schema{
				AllOf: []*base.SchemaProxy{refProxy},
			}
		}
		// Default to string if unknown type
		return &base.Schema{Type: []string{schemaTypeString}}
	}
}

// addResourceToPaths adds resource endpoints to paths using native v3 types.
func (g *generator) addResourceToPaths(resource specification.Resource, paths *orderedmap.Map[string, *v3.PathItem], service *specification.Service) {
	// Group endpoints by path
	pathGroups := make(map[string][]*specification.Endpoint)
	for _, endpoint := range resource.Endpoints {
		fullPath := endpoint.GetFullPath(resource.Name)
		pathGroups[fullPath] = append(pathGroups[fullPath], &endpoint)
	}

	// Get sorted list of paths for deterministic iteration
	sortedPaths := make([]string, 0, len(pathGroups))
	for path := range pathGroups {
		sortedPaths = append(sortedPaths, path)
	}
	sort.Strings(sortedPaths)

	// Create PathItem for each unique path in sorted order
	for _, path := range sortedPaths {
		endpoints := pathGroups[path]
		pathItem := &v3.PathItem{}

		for _, endpoint := range endpoints {
			operation := g.createOperation(*endpoint, resource, service)

			// Set operation based on HTTP method
			switch strings.ToUpper(endpoint.Method) {
			case http.MethodGet:
				pathItem.Get = operation
			case http.MethodPost:
				pathItem.Post = operation
			case http.MethodPatch:
				pathItem.Patch = operation
			case http.MethodPut:
				pathItem.Put = operation
			case http.MethodDelete:
				pathItem.Delete = operation
			}
		}

		paths.Set(path, pathItem)
	}
}

// createOperation creates a v3.Operation from an endpoint using native types.
func (g *generator) createOperation(endpoint specification.Endpoint, resource specification.Resource, service *specification.Service) *v3.Operation {
	operation := &v3.Operation{
		OperationId: resource.Name + endpoint.Name,
		Summary:     endpoint.Summary,
		Description: endpoint.Description,
		Tags:        []string{resource.Name},
	}

	// Add parameters
	parameters := []*v3.Parameter{}

	// Path parameters
	for _, param := range endpoint.Request.PathParams {
		parameters = append(parameters, g.createParameter(param, "path", service))
	}

	// Query parameters
	for _, param := range endpoint.Request.QueryParams {
		parameters = append(parameters, g.createParameter(param, "query", service))
	}

	operation.Parameters = parameters

	// Request body - use reference to components section instead of inline definition
	if len(endpoint.Request.BodyParams) > 0 {
		operation.RequestBody = g.createRequestBodyReference(resource.Name, endpoint.Name)
	}

	// Responses
	responses := orderedmap.New[string, *v3.Response]()

	// Success response
	successResponse := g.createResponseReference(endpoint.Response, resource.Name, endpoint.Name, service)
	responses.Set(strconv.Itoa(endpoint.Response.StatusCode), successResponse)

	// Add error responses
	g.addErrorResponses(responses, endpoint, resource, service)

	operation.Responses = &v3.Responses{
		Codes: responses,
	}

	// Add Speakeasy pagination extension if this is a paginated operation
	if g.isPaginatedOperation(endpoint) {
		g.addSpeakeasyPaginationExtension(operation)
	}

	// Add Speakeasy operation naming extensions
	g.addSpeakeasyOperationNamingExtensions(operation, endpoint, resource)

	return operation
}

// createParameter creates a v3.Parameter from a field using native types.
func (g *generator) createParameter(field specification.Field, location string, service *specification.Service) *v3.Parameter {
	isRequired := field.IsRequired(service)
	param := &v3.Parameter{
		Name:        field.TagJSON(),
		In:          location,
		Description: field.Description,
		Required:    &isRequired,
		Schema:      base.CreateSchemaProxy(g.createParameterSchema(field, service)),
	}

	return param
}

// addRequestBodiesToComponents extracts request bodies from all endpoints and adds them to the components section.
func (g *generator) addRequestBodiesToComponents(components *v3.Components, service *specification.Service) {
	// Track unique request bodies to avoid duplicates
	requestBodyMap := make(map[string]*v3.RequestBody)

	// Iterate through all resources and endpoints to collect request bodies
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			if len(endpoint.Request.BodyParams) > 0 {
				requestBodyName := g.createRequestBodyName(resource.Name, endpoint.Name)

				// Only add if we haven't seen this request body before
				if _, exists := requestBodyMap[requestBodyName]; !exists {
					requestBody := g.createComponentRequestBody(endpoint.Request.BodyParams, service)
					requestBodyMap[requestBodyName] = requestBody
					components.RequestBodies.Set(requestBodyName, requestBody)
				}
			}
		}
	}
}

// createRequestBodyName creates a systematic name for request bodies.
func (g *generator) createRequestBodyName(resourceName, endpointName string) string {
	return resourceName + endpointName
}

// isPrimitiveType returns true if the field type is a primitive type.
func (g *generator) isPrimitiveType(fieldType string) bool {
	switch fieldType {
	case specification.FieldTypeUUID, specification.FieldTypeDate, specification.FieldTypeTimestamp,
		specification.FieldTypeString, specification.FieldTypeInt, specification.FieldTypeBool:
		return true
	default:
		return false
	}
}

// createTypedExampleNode creates a properly typed YAML node for an example value based on the field type.
func (g *generator) createTypedExampleNode(fieldType, exampleValue string) *yaml.Node {
	switch fieldType {
	case specification.FieldTypeInt:
		// For integer types, create a numeric node
		return &yaml.Node{
			Kind:  yaml.ScalarNode,
			Tag:   "!!int",
			Value: exampleValue,
		}
	case specification.FieldTypeBool:
		// For boolean types, create a boolean node
		return &yaml.Node{
			Kind:  yaml.ScalarNode,
			Tag:   "!!bool",
			Value: exampleValue,
		}
	case specification.FieldTypeString, specification.FieldTypeUUID,
		specification.FieldTypeDate, specification.FieldTypeTimestamp:
		// For string-based types, create a string node
		return &yaml.Node{
			Kind:  yaml.ScalarNode,
			Tag:   "!!str",
			Value: exampleValue,
		}
	default:
		// For enums and other types, default to string
		return &yaml.Node{
			Kind:  yaml.ScalarNode,
			Tag:   "!!str",
			Value: exampleValue,
		}
	}
}

// createNullExampleNode creates a YAML node representing a null value.
func (g *generator) createNullExampleNode() *yaml.Node {
	return &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!null",
		Value: "null",
	}
}

// generateRequestBodyExample generates an example value for a request body based on the body parameters.
// For enum/primitive fields with examples, it uses the field example directly.
// For object fields, it traverses to the object and builds examples from the object's fields.
func (g *generator) generateRequestBodyExample(bodyParams []specification.Field, service *specification.Service) *yaml.Node {
	if len(bodyParams) == 0 {
		return nil
	}

	// Always create an object example with field names as keys
	// This ensures the example matches the actual request body structure
	return g.generateObjectExampleFromFields(bodyParams, service)
}

// generateObjectExampleWithVisited generates an example from an object definition with circular reference protection.
func (g *generator) generateObjectExampleWithVisited(obj specification.Object, service *specification.Service, visited map[string]bool) *yaml.Node {
	// Check for circular reference
	if visited[obj.Name] {
		return nil
	}

	// Mark this object as visited
	visited[obj.Name] = true
	defer func() {
		// Unmark when done (allows the same object to be used in different branches)
		delete(visited, obj.Name)
	}()

	return g.generateObjectExampleFromFieldsWithVisited(obj.Fields, service, visited)
}

// generateObjectExampleFromFields generates an example object from a slice of fields.
func (g *generator) generateObjectExampleFromFields(fields []specification.Field, service *specification.Service) *yaml.Node {
	visited := make(map[string]bool)
	return g.generateObjectExampleFromFieldsWithVisited(fields, service, visited)
}

// generateObjectExampleFromFieldsWithVisited generates an example object from a slice of fields with circular reference protection.
func (g *generator) generateObjectExampleFromFieldsWithVisited(fields []specification.Field, service *specification.Service, visited map[string]bool) *yaml.Node {
	if len(fields) == 0 {
		return nil
	}

	// Create object node
	objNode := &yaml.Node{
		Kind: yaml.MappingNode,
		Tag:  "!!map",
	}

	hasAnyExample := false

	for _, field := range fields {
		var valueNode *yaml.Node

		// For enum or primitive types, use field example if available
		if g.isPrimitiveType(field.Type) || service.HasEnum(field.Type) {
			if field.Example != "" {
				valueNode = g.createTypedExampleNode(field.Type, field.Example)
			}
		} else if service.HasObject(field.Type) {
			// For object types, recursively generate example from object definition with circular reference protection
			obj := service.GetObject(field.Type)
			if obj != nil && !visited[field.Type] {
				valueNode = g.generateObjectExampleWithVisited(*obj, service, visited)
			}
		}

		// Handle array modifier - wrap the value in an array if needed
		if valueNode != nil && field.IsArray() {
			arrayNode := &yaml.Node{
				Kind: yaml.SequenceNode,
				Tag:  "!!seq",
			}
			arrayNode.Content = append(arrayNode.Content, valueNode)
			valueNode = arrayNode
		}

		// Only add field to example if we have a value
		if valueNode != nil {
			// Add field name
			keyNode := &yaml.Node{
				Kind:  yaml.ScalarNode,
				Tag:   "!!str",
				Value: field.TagJSON(),
			}
			objNode.Content = append(objNode.Content, keyNode)
			objNode.Content = append(objNode.Content, valueNode)
			hasAnyExample = true
		}
	}

	if !hasAnyExample {
		return nil
	}

	return objNode
}

// generateResponseBodyExample generates an example value for a response body based on the response definition.
// For responses with BodyObject, it generates an example from the object definition.
// For responses with BodyFields, it generates an example from the field definitions.
func (g *generator) generateResponseBodyExample(response specification.EndpointResponse, service *specification.Service) *yaml.Node {
	// If response has a body object, generate example from the object definition
	if response.BodyObject != nil {
		if service.HasObject(*response.BodyObject) {
			obj := service.GetObject(*response.BodyObject)
			if obj != nil {
				visited := make(map[string]bool)
				return g.generateObjectExampleWithVisited(*obj, service, visited)
			}
		}
		return nil
	}

	// If response has body fields, generate example from the fields
	if len(response.BodyFields) > 0 {
		return g.generateObjectExampleFromFields(response.BodyFields, service)
	}

	// No response body content
	return nil
}

// createComponentRequestBody creates a v3.RequestBody for the components section.
func (g *generator) createComponentRequestBody(bodyParams []specification.Field, service *specification.Service) *v3.RequestBody {
	// Always wrap body parameters in an object with field names as properties
	// This ensures consistency between schema and examples
	schema := &base.Schema{
		Type:       []string{schemaTypeObject},
		Properties: orderedmap.New[string, *base.SchemaProxy](),
	}

	requiredFields := []string{}
	for _, field := range bodyParams {
		fieldSchema := g.createFieldSchema(field, service)
		proxy := base.CreateSchemaProxy(fieldSchema)
		schema.Properties.Set(field.TagJSON(), proxy)

		if field.IsRequired(service) {
			requiredFields = append(requiredFields, field.TagJSON())
		}
	}

	if len(requiredFields) > 0 {
		schema.Required = requiredFields
	}

	isRequired := len(requiredFields) > 0

	// Create media type
	mediaType := &v3.MediaType{
		Schema: base.CreateSchemaProxy(schema),
	}

	// Generate examples for the request body
	if example := g.generateRequestBodyExample(bodyParams, service); example != nil {
		// Use Examples (plural) for complex objects per OpenAPI 3.0+ specification
		examples := orderedmap.New[string, *base.Example]()
		examples.Set("requestExample", &base.Example{
			Summary: "Request body example",
			Value:   example,
		})
		mediaType.Examples = examples
	}

	content := orderedmap.New[string, *v3.MediaType]()
	content.Set(contentTypeJSON, mediaType)

	return &v3.RequestBody{
		Description: requestBodyDescription,
		Content:     content,
		Required:    &isRequired,
	}
}

// addResponseBodiesToComponents extracts response bodies from all endpoints and adds them to the components section.
func (g *generator) addResponseBodiesToComponents(components *v3.Components, service *specification.Service) {
	// Track unique response bodies to avoid duplicates
	responseBodyMap := make(map[string]*v3.Response)

	// Iterate through all resources and endpoints to collect response bodies
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			// Add success response body if it has content
			if endpoint.Response.BodyObject != nil || len(endpoint.Response.BodyFields) > 0 {
				responseBodyName := g.createResponseBodyName(resource.Name, endpoint.Name, endpoint.Response.StatusCode)

				// Only add if we haven't seen this response body before
				if _, exists := responseBodyMap[responseBodyName]; !exists {
					responseBody := g.createComponentResponse(endpoint.Response, resource.Name, endpoint.Name, service)
					responseBodyMap[responseBodyName] = responseBody
					components.Responses.Set(responseBodyName, responseBody)
				}
			}

			// Add endpoint-specific 422 error response if endpoint has body parameters
			if len(endpoint.Request.BodyParams) > 0 {
				response422Name := resource.Name + endpoint.Name + httpStatus422 + responseBodySuffix
				if _, exists := responseBodyMap[response422Name]; !exists {
					// Create 422 validation error response
					response422 := g.createEndpointSpecific422ErrorResponse(resource.Name, endpoint.Name, service)
					responseBodyMap[response422Name] = response422
					components.Responses.Set(response422Name, response422)
				}
			}
		}
	}

	// Add common error response bodies
	g.addErrorResponseBodiesToComponents(components, service)
}

// createResponseBodyName creates a systematic name for response bodies.
func (g *generator) createResponseBodyName(resourceName, endpointName string, statusCode int) string {
	return resourceName + endpointName
}

// generateAutoResponseDescription creates unique descriptions for autogenerated responses.
func (g *generator) generateAutoResponseDescription(resourceName, endpointName string, existingDescription string) string {
	// Generate unique description based on operation type - prioritize autogenerated descriptions
	switch endpointName {
	case "Create":
		return fmt.Sprintf(autoResponseCreateTemplate, resourceName, resourceName)
	case "Update":
		return fmt.Sprintf(autoResponseUpdateTemplate, resourceName, resourceName)
	case "Delete":
		return fmt.Sprintf(autoResponseDeleteTemplate, resourceName)
	case "Get":
		return fmt.Sprintf(autoResponseGetTemplate, resourceName, resourceName)
	case "List":
		return fmt.Sprintf(autoResponseListTemplate, resourceName, resourceName)
	case "Search":
		return fmt.Sprintf(autoResponseSearchTemplate, resourceName, resourceName)
	default:
		// For custom endpoints, use existing description if available, otherwise generate generic
		if existingDescription != "" {
			return existingDescription
		}
		return fmt.Sprintf("Response for %s %s operation", resourceName, endpointName)
	}
}

// generateAutoErrorDescription creates unique descriptions for autogenerated error responses.
func (g *generator) generateAutoErrorDescription(resourceName, endpointName, statusCode string) string {
	// Generate unique description based on error status code
	switch statusCode {
	case httpStatus400:
		return fmt.Sprintf(autoErrorBadRequestTemplate, resourceName, endpointName)
	case httpStatus401:
		return fmt.Sprintf(autoErrorUnauthorizedTemplate, resourceName, endpointName)
	case httpStatus403:
		return fmt.Sprintf(autoErrorForbiddenTemplate, resourceName, endpointName)
	case httpStatus404:
		return fmt.Sprintf(autoErrorNotFoundTemplate, resourceName, endpointName)
	case httpStatus409:
		return fmt.Sprintf(autoErrorConflictTemplate, resourceName, endpointName)
	case httpStatus422:
		return fmt.Sprintf(autoErrorUnprocessableTemplate, resourceName, endpointName)
	case httpStatus429:
		return fmt.Sprintf(autoErrorRateLimitTemplate, resourceName, endpointName)
	case httpStatus500:
		return fmt.Sprintf(autoErrorInternalTemplate, resourceName, endpointName)
	default:
		// For other status codes, create a generic error description
		return fmt.Sprintf("Error response for %s %s operation - status code %s", resourceName, endpointName, statusCode)
	}
}

// createResponseHeaders creates an ordered map of response headers from the service's common response headers.
func (g *generator) createResponseHeaders(service *specification.Service) *orderedmap.Map[string, *v3.Header] {
	if len(service.ResponseHeaders) == 0 {
		return nil
	}

	headers := orderedmap.New[string, *v3.Header]()
	for _, headerField := range service.ResponseHeaders {
		header := &v3.Header{
			Description: headerField.Description,
			Schema:      base.CreateSchemaProxy(g.createParameterSchema(headerField, service)),
		}
		headers.Set(headerField.Name, header)
	}
	return headers
}

// createComponentResponse creates a v3.Response for the components section.
func (g *generator) createComponentResponse(response specification.EndpointResponse, resourceName, endpointName string, service *specification.Service) *v3.Response {
	componentResponse := &v3.Response{}

	// Generate unique description that includes operation name
	description := g.generateAutoResponseDescription(resourceName, endpointName, response.Description)
	if description != "" {
		componentResponse.Description = description
	}

	// Add common response headers
	if headers := g.createResponseHeaders(service); headers != nil {
		componentResponse.Headers = headers
	}

	// Add response content if present
	if response.BodyObject != nil || len(response.BodyFields) > 0 {
		content := orderedmap.New[string, *v3.MediaType]()

		var schema *base.Schema
		if response.BodyObject != nil {
			// Create a proper $ref schema reference using allOf
			refString := schemaReferencePrefix + *response.BodyObject
			refProxy := base.CreateSchemaProxyRef(refString)
			schema = &base.Schema{
				AllOf: []*base.SchemaProxy{refProxy},
			}
		} else if len(response.BodyFields) > 0 {
			// Inline schema from body fields
			schema = &base.Schema{
				Type:       []string{schemaTypeObject},
				Properties: orderedmap.New[string, *base.SchemaProxy](),
			}

			for _, field := range response.BodyFields {
				fieldSchema := g.createFieldSchema(field, service)

				// Add example to field property if field has example
				if field.Example != "" {
					exampleNode := g.createTypedExampleNode(field.Type, field.Example)
					// Handle array modifier - wrap the value in an array if needed
					if field.IsArray() {
						arrayNode := &yaml.Node{
							Kind: yaml.SequenceNode,
						}
						arrayNode.Content = append(arrayNode.Content, exampleNode)
						exampleNode = arrayNode
					}
					fieldSchema.Examples = []*yaml.Node{exampleNode}
				} else if field.IsArray() && service.HasObject(field.Type) {
					// Generate example array from object definition
					if obj := service.GetObject(field.Type); obj != nil {
						visited := make(map[string]bool)
						if objectExample := g.generateObjectExampleWithVisited(*obj, service, visited); objectExample != nil {
							arrayNode := &yaml.Node{
								Kind: yaml.SequenceNode,
							}
							arrayNode.Content = append(arrayNode.Content, objectExample)
							fieldSchema.Examples = []*yaml.Node{arrayNode}
						}
					}
				} else if service.HasObject(field.Type) {
					// Generate example from object definition
					if obj := service.GetObject(field.Type); obj != nil {
						visited := make(map[string]bool)
						if objectExample := g.generateObjectExampleWithVisited(*obj, service, visited); objectExample != nil {
							fieldSchema.Examples = []*yaml.Node{objectExample}
						}
					}
				}

				proxy := base.CreateSchemaProxy(fieldSchema)
				schema.Properties.Set(field.TagJSON(), proxy)
			}
		}

		if schema != nil {
			mediaType := &v3.MediaType{
				Schema: base.CreateSchemaProxy(schema),
			}

			// Generate response example
			if responseExample := g.generateResponseBodyExample(response, service); responseExample != nil {
				// Use Examples (plural) for complex objects per OpenAPI 3.0+ specification
				examples := orderedmap.New[string, *base.Example]()
				examples.Set("responseExample", &base.Example{
					Summary: "Response body example",
					Value:   responseExample,
				})
				mediaType.Examples = examples
			}

			content.Set(contentTypeJSON, mediaType)
			componentResponse.Content = content
		}
	}

	return componentResponse
}

// generate422ErrorExample generates a realistic example for a 422 error response.
func (g *generator) generate422ErrorExample(resourceName, endpointName string, service *specification.Service) *yaml.Node {
	// Create the root object
	rootNode := &yaml.Node{
		Kind: yaml.MappingNode,
	}

	// Add error field as Error object with code and message
	errorKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: errorFieldName,
	}
	errorValueNode := g.generateErrorObjectExample(resourceName, endpointName)
	rootNode.Content = append(rootNode.Content, errorKeyNode, errorValueNode)

	return rootNode
}

// generateErrorObjectExample generates an Error object example with code, message, and requestID fields.
func (g *generator) generateErrorObjectExample(resourceName, endpointName string) *yaml.Node {
	errorObjectNode := &yaml.Node{
		Kind: yaml.MappingNode,
	}

	// Add code field
	codeKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: codeFieldName,
	}
	codeValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: errorCodeUnprocessableEntity,
	}
	errorObjectNode.Content = append(errorObjectNode.Content, codeKeyNode, codeValueNode)

	// Add message field
	messageKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: messageFieldName,
	}
	messageValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: fmt.Sprintf("Validation failed for %s %s endpoint", resourceName, endpointName),
	}
	errorObjectNode.Content = append(errorObjectNode.Content, messageKeyNode, messageValueNode)

	// Add requestID field
	requestIDKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: requestIDFieldName,
	}
	requestIDValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: "550e8400-e29b-41d4-a716-446655440000",
	}
	errorObjectNode.Content = append(errorObjectNode.Content, requestIDKeyNode, requestIDValueNode)

	return errorObjectNode
}

// createEndpointSpecific422ErrorResponse creates a 422 error response component for an endpoint.
func (g *generator) createEndpointSpecific422ErrorResponse(resourceName, endpointName string, service *specification.Service) *v3.Response {
	// Create schema with only error field (ErrorCode)
	schema := &base.Schema{
		Type:       []string{schemaTypeObject},
		Properties: orderedmap.New[string, *base.SchemaProxy](),
	}

	// Add error field using Error object
	var errorSchema *base.Schema
	if service.HasObject(errorObjectName) {
		// Reference the Error object
		refString := schemaReferencePrefix + errorObjectName
		refProxy := base.CreateSchemaProxyRef(refString)
		errorSchema = &base.Schema{
			AllOf: []*base.SchemaProxy{refProxy},
		}
	} else {
		// Fallback to generic error object schema
		errorSchema = &base.Schema{
			Type:       []string{schemaTypeObject},
			Properties: orderedmap.New[string, *base.SchemaProxy](),
		}
		messageSchema := &base.Schema{Type: []string{schemaTypeString}}
		codeSchema := &base.Schema{Type: []string{schemaTypeString}}
		errorSchema.Properties.Set(messageFieldName, base.CreateSchemaProxy(messageSchema))
		errorSchema.Properties.Set(codeFieldName, base.CreateSchemaProxy(codeSchema))
		errorSchema.Required = []string{messageFieldName, codeFieldName}
	}

	// Add example to error property
	if errorExampleNode := g.generateErrorObjectExample(resourceName, endpointName); errorExampleNode != nil {
		errorSchema.Examples = []*yaml.Node{errorExampleNode}
	}

	schema.Properties.Set(errorFieldName, base.CreateSchemaProxy(errorSchema))
	schema.Required = []string{errorFieldName}

	content := orderedmap.New[string, *v3.MediaType]()
	mediaType := &v3.MediaType{
		Schema: base.CreateSchemaProxy(schema),
	}

	// Generate 422 error response example
	if errorExample := g.generate422ErrorExample(resourceName, endpointName, service); errorExample != nil {
		// Use Examples (plural) for complex objects per OpenAPI 3.0+ specification
		examples := orderedmap.New[string, *base.Example]()
		examples.Set("validationError", &base.Example{
			Summary: "Validation error example",
			Value:   errorExample,
		})
		mediaType.Examples = examples
	}

	content.Set(contentTypeJSON, mediaType)

	response := &v3.Response{
		Description: g.generateAutoErrorDescription(resourceName, endpointName, httpStatus422),
		Content:     content,
	}

	// Add common response headers
	if headers := g.createResponseHeaders(service); headers != nil {
		response.Headers = headers
	}

	return response
}

// createResponseReference creates a v3.Response that references a component response body.
func (g *generator) createResponseReference(response specification.EndpointResponse, resourceName, endpointName string, service *specification.Service) *v3.Response {
	// Check if this response has content that should be referenced
	if response.BodyObject != nil || len(response.BodyFields) > 0 {
		// Since v3.Response doesn't directly support references, we use the Extensions field
		// with a $ref YAML node to create a reference that serializes properly
		responseBodyName := g.createResponseBodyName(resourceName, endpointName, response.StatusCode)
		refString := responseBodyReferencePrefix + responseBodyName

		// Create an extension map with a $ref node
		extensions := orderedmap.New[string, *yaml.Node]()
		extensions.Set("$ref", &yaml.Node{Kind: yaml.ScalarNode, Tag: "!!str", Value: refString})

		// Return a response that serializes as a reference
		// Generate unique description for autogenerated responses
		result := &v3.Response{
			Extensions: extensions,
		}

		// Generate unique description that includes operation name
		description := g.generateAutoResponseDescription(resourceName, endpointName, response.Description)
		if description != "" {
			result.Description = description
		}
		return result
	}

	// For responses without content, return the inline response
	return g.createResponse(response, resourceName, endpointName, service)
}

// generateStandardErrorObjectExample generates an error object example YAML node (without wrapper) for standard error responses.
func (g *generator) generateStandardErrorObjectExample(errorCode, message string) *yaml.Node {
	// Create the error object node
	errorObjectNode := &yaml.Node{
		Kind: yaml.MappingNode,
	}

	// Add code field
	codeKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: codeFieldName,
	}
	codeValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: errorCode,
	}
	errorObjectNode.Content = append(errorObjectNode.Content, codeKeyNode, codeValueNode)

	// Add message field
	messageKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: messageFieldName,
	}
	messageValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: message,
	}
	errorObjectNode.Content = append(errorObjectNode.Content, messageKeyNode, messageValueNode)

	// Add requestID field
	requestIDKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: requestIDFieldName,
	}
	requestIDValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: "550e8400-e29b-41d4-a716-446655440000",
	}
	errorObjectNode.Content = append(errorObjectNode.Content, requestIDKeyNode, requestIDValueNode)

	return errorObjectNode
}

// createWrappedErrorSchema creates an error response schema with the error wrapped in an "error" object.
func (g *generator) createWrappedErrorSchema(service *specification.Service) *base.Schema {
	// Create the inner error object schema
	var innerErrorSchema *base.Schema
	if service.HasObject(errorObjectName) {
		// Create a proper $ref schema reference using allOf
		refString := schemaReferencePrefix + errorObjectName
		refProxy := base.CreateSchemaProxyRef(refString)
		innerErrorSchema = &base.Schema{
			AllOf: []*base.SchemaProxy{refProxy},
		}

		// Add example to the inner error schema to satisfy linter requirements
		errorObjectExample := g.generateStandardErrorObjectExample(errorCodeBadRequest, "The request contains invalid parameters or malformed data")
		if errorObjectExample != nil {
			innerErrorSchema.Examples = []*yaml.Node{errorObjectExample}
		}
	} else {
		// Fallback generic error schema
		innerErrorSchema = &base.Schema{
			Type:       []string{schemaTypeObject},
			Properties: orderedmap.New[string, *base.SchemaProxy](),
		}
		messageSchema := &base.Schema{Type: []string{schemaTypeString}}
		codeSchema := &base.Schema{Type: []string{schemaTypeString}}
		innerErrorSchema.Properties.Set(messageFieldName, base.CreateSchemaProxy(messageSchema))
		innerErrorSchema.Properties.Set(codeFieldName, base.CreateSchemaProxy(codeSchema))
		innerErrorSchema.Required = []string{messageFieldName, codeFieldName}

		// Add example to the fallback schema as well
		errorObjectExample := g.generateStandardErrorObjectExample(errorCodeBadRequest, "The request contains invalid parameters or malformed data")
		if errorObjectExample != nil {
			innerErrorSchema.Examples = []*yaml.Node{errorObjectExample}
		}
	}

	// Create the wrapper schema with "error" field
	wrapperSchema := &base.Schema{
		Type:       []string{schemaTypeObject},
		Properties: orderedmap.New[string, *base.SchemaProxy](),
	}
	wrapperSchema.Properties.Set(errorFieldName, base.CreateSchemaProxy(innerErrorSchema))
	wrapperSchema.Required = []string{errorFieldName}

	return wrapperSchema
}

// generateStandardErrorExample generates a wrapped error example YAML node for standard error responses.
func (g *generator) generateStandardErrorExample(errorCode, message string) *yaml.Node {
	// Create the wrapper object node (contains the "error" field)
	wrapperNode := &yaml.Node{
		Kind: yaml.MappingNode,
	}

	// Add error field key
	errorKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: errorFieldName,
	}

	// Create the error object node
	errorObjectNode := &yaml.Node{
		Kind: yaml.MappingNode,
	}

	// Add code field
	codeKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: codeFieldName,
	}
	codeValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: errorCode,
	}
	errorObjectNode.Content = append(errorObjectNode.Content, codeKeyNode, codeValueNode)

	// Add message field
	messageKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: messageFieldName,
	}
	messageValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: message,
	}
	errorObjectNode.Content = append(errorObjectNode.Content, messageKeyNode, messageValueNode)

	// Add requestID field
	requestIDKeyNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: requestIDFieldName,
	}
	requestIDValueNode := &yaml.Node{
		Kind:  yaml.ScalarNode,
		Tag:   "!!str",
		Value: "550e8400-e29b-41d4-a716-446655440000",
	}
	errorObjectNode.Content = append(errorObjectNode.Content, requestIDKeyNode, requestIDValueNode)

	// Add the error object to the wrapper
	wrapperNode.Content = append(wrapperNode.Content, errorKeyNode, errorObjectNode)

	return wrapperNode
}

// addErrorResponseBodiesToComponents adds common error response bodies to the components section.
func (g *generator) addErrorResponseBodiesToComponents(components *v3.Components, service *specification.Service) {
	// Create standard wrapped error schema
	standardErrorSchema := g.createWrappedErrorSchema(service)

	// Define common error responses with examples in deterministic order
	errorResponses := []struct {
		description    string
		statusCode     string
		errorCode      string
		message        string
		exampleSummary string
	}{
		{
			badRequestDescription,
			httpStatus400,
			errorCodeBadRequest,
			"The request contains invalid parameters or malformed data",
			"Bad Request error example",
		},
		{
			unauthorizedDescription,
			httpStatus401,
			errorCodeUnauthorized,
			"Authentication credentials are missing or invalid",
			"Unauthorized error example",
		},
		{
			"Forbidden - Request is authenticated, but the user is not allowed to perform the operation",
			httpStatus403,
			errorCodeForbidden,
			"You do not have permission to perform this operation",
			"Forbidden error example",
		},
		{
			notFoundDescription,
			httpStatus404,
			errorCodeNotFound,
			"The requested resource could not be found",
			"Not Found error example",
		},
		{
			"Conflict - The request could not be completed due to a conflict",
			httpStatus409,
			errorCodeConflict,
			"The request conflicts with the current state of the resource",
			"Conflict error example",
		},
		{
			"Too Many Requests - When the rate limit has been exceeded",
			httpStatus429,
			errorCodeRateLimited,
			"Too many requests - rate limit exceeded",
			"Rate Limited error example",
		},
		{
			internalErrorDescription,
			httpStatus500,
			errorCodeInternal,
			"An unexpected server error occurred",
			"Internal Server error example",
		},
	}

	for _, errorResponse := range errorResponses {
		// Generate error example using YAML nodes
		errorExample := g.generateStandardErrorExample(errorResponse.errorCode, errorResponse.message)

		// Create MediaType with schema and examples
		mediaType := &v3.MediaType{
			Schema: base.CreateSchemaProxy(standardErrorSchema),
		}

		if errorExample != nil {
			// Use Examples (plural) for complex objects per OpenAPI 3.0+ specification
			examples := orderedmap.New[string, *base.Example]()
			examples.Set("errorExample", &base.Example{
				Summary: errorResponse.exampleSummary,
				Value:   errorExample,
			})
			mediaType.Examples = examples
		}

		content := orderedmap.New[string, *v3.MediaType]()
		content.Set(contentTypeJSON, mediaType)

		// Add standard error response
		standardResponseBodyName := errorResponseBodyPrefix + errorResponse.statusCode + responseBodySuffix
		standardResponse := &v3.Response{
			Description: errorResponse.description,
			Content:     content,
		}

		// Add common response headers to error responses as well
		if headers := g.createResponseHeaders(service); headers != nil {
			standardResponse.Headers = headers
		}

		components.Responses.Set(standardResponseBodyName, standardResponse)
	}
}

// createResponse creates a v3.Response from an endpoint response using native types.
func (g *generator) createResponse(response specification.EndpointResponse, resourceName, endpointName string, service *specification.Service) *v3.Response {
	openAPIResponse := &v3.Response{}

	// Generate unique description that includes operation name
	description := g.generateAutoResponseDescription(resourceName, endpointName, response.Description)
	if description != "" {
		openAPIResponse.Description = description
	}

	// Add common response headers
	if headers := g.createResponseHeaders(service); headers != nil {
		openAPIResponse.Headers = headers
	}

	// Add response content if present
	if response.BodyObject != nil || len(response.BodyFields) > 0 {
		content := orderedmap.New[string, *v3.MediaType]()

		var schema *base.Schema
		if response.BodyObject != nil {
			// Create a proper $ref schema reference using allOf
			refString := schemaReferencePrefix + *response.BodyObject
			refProxy := base.CreateSchemaProxyRef(refString)
			schema = &base.Schema{
				AllOf: []*base.SchemaProxy{refProxy},
			}
		} else if len(response.BodyFields) > 0 {
			// Inline schema from body fields
			schema = &base.Schema{
				Type:       []string{schemaTypeObject},
				Properties: orderedmap.New[string, *base.SchemaProxy](),
			}

			for _, field := range response.BodyFields {
				fieldSchema := g.createFieldSchema(field, service)

				// Add example to field property if field has example
				if field.Example != "" {
					exampleNode := g.createTypedExampleNode(field.Type, field.Example)
					// Handle array modifier - wrap the value in an array if needed
					if field.IsArray() {
						arrayNode := &yaml.Node{
							Kind: yaml.SequenceNode,
						}
						arrayNode.Content = append(arrayNode.Content, exampleNode)
						exampleNode = arrayNode
					}
					fieldSchema.Examples = []*yaml.Node{exampleNode}
				} else if field.IsArray() && service.HasObject(field.Type) {
					// Generate example array from object definition
					if obj := service.GetObject(field.Type); obj != nil {
						visited := make(map[string]bool)
						if objectExample := g.generateObjectExampleWithVisited(*obj, service, visited); objectExample != nil {
							arrayNode := &yaml.Node{
								Kind: yaml.SequenceNode,
							}
							arrayNode.Content = append(arrayNode.Content, objectExample)
							fieldSchema.Examples = []*yaml.Node{arrayNode}
						}
					}
				} else if service.HasObject(field.Type) {
					// Generate example from object definition
					if obj := service.GetObject(field.Type); obj != nil {
						visited := make(map[string]bool)
						if objectExample := g.generateObjectExampleWithVisited(*obj, service, visited); objectExample != nil {
							fieldSchema.Examples = []*yaml.Node{objectExample}
						}
					}
				}

				proxy := base.CreateSchemaProxy(fieldSchema)
				schema.Properties.Set(field.TagJSON(), proxy)
			}
		}

		if schema != nil {
			mediaType := &v3.MediaType{
				Schema: base.CreateSchemaProxy(schema),
			}

			// Generate response example
			if responseExample := g.generateResponseBodyExample(response, service); responseExample != nil {
				// Use Examples (plural) for complex objects per OpenAPI 3.0+ specification
				examples := orderedmap.New[string, *base.Example]()
				examples.Set("responseExample", &base.Example{
					Summary: "Response body example",
					Value:   responseExample,
				})
				mediaType.Examples = examples
			}

			content.Set(contentTypeJSON, mediaType)
			openAPIResponse.Content = content
		}
	}

	return openAPIResponse
}

// addErrorResponses adds error responses based on errorCodes from the specification.
func (g *generator) addErrorResponses(responses *orderedmap.Map[string, *v3.Response], endpoint specification.Endpoint, resource specification.Resource, service *specification.Service) {
	// Check if endpoint has body parameters
	hasBodyParams := len(endpoint.Request.BodyParams) > 0

	// Find ErrorCode enum in the service
	var errorCodeEnum *specification.Enum
	for i, enum := range service.Enums {
		if enum.Name == errorCodeEnumName {
			errorCodeEnum = &service.Enums[i]
			break
		}
	}

	if errorCodeEnum == nil {
		// Fallback to default error responses if ErrorCode enum not found
		g.addDefaultErrorResponseReferences(responses, endpoint, resource, service)
		return
	}

	// Generate responses for each error code
	for _, enumValue := range errorCodeEnum.Values {
		statusCode, _ := g.mapErrorCodeToStatusAndDescription(enumValue.Name, enumValue.Description)

		// Skip 422 UnprocessableEntity if endpoint has no body parameters
		if statusCode == httpStatus422 && !hasBodyParams {
			continue
		}

		var errorResponse *v3.Response
		if statusCode == httpStatus422 && hasBodyParams {
			// Use endpoint-specific error response for 422 validation errors
			errorResponse = g.createEndpointSpecificErrorResponseReference(statusCode, resource.Name, endpoint.Name)
		} else {
			// Use generic error response for all other status codes
			errorResponse = g.createErrorResponseReference(statusCode, resource.Name, endpoint.Name, hasBodyParams)
		}
		responses.Set(statusCode, errorResponse)
	}
}

// addDefaultErrorResponseReferences adds fallback error response references when ErrorCode enum is not found.
func (g *generator) addDefaultErrorResponseReferences(responses *orderedmap.Map[string, *v3.Response], endpoint specification.Endpoint, resource specification.Resource, service *specification.Service) {
	// Check if endpoint has body parameters to determine appropriate schema
	hasBodyParams := len(endpoint.Request.BodyParams) > 0

	// Define default error status codes and descriptions in deterministic order
	defaultErrors := []struct {
		statusCode  string
		description string
	}{
		{httpStatus400, badRequestDescription},
		{httpStatus401, unauthorizedDescription},
		{httpStatus404, notFoundDescription},
		{httpStatus500, internalErrorDescription},
	}

	for _, defaultError := range defaultErrors {
		// Use reference to component error response (all default errors use generic responses)
		errorResponse := g.createErrorResponseReference(defaultError.statusCode, resource.Name, endpoint.Name, hasBodyParams)
		responses.Set(defaultError.statusCode, errorResponse)
	}
}

// mapErrorCodeToStatusAndDescription maps error code names to HTTP status codes and descriptions.
func (g *generator) mapErrorCodeToStatusAndDescription(errorCodeName, errorCodeDescription string) (string, string) {
	switch errorCodeName {
	case errorCodeBadRequest:
		return httpStatus400, errorCodeDescription
	case errorCodeUnauthorized:
		return httpStatus401, errorCodeDescription
	case errorCodeForbidden:
		return httpStatus403, errorCodeDescription
	case errorCodeNotFound:
		return httpStatus404, errorCodeDescription
	case errorCodeConflict:
		return httpStatus409, errorCodeDescription
	case errorCodeUnprocessableEntity:
		return httpStatus422, errorCodeDescription
	case errorCodeRateLimited:
		return httpStatus429, errorCodeDescription
	case errorCodeInternal:
		return httpStatus500, errorCodeDescription
	default:
		// Default to 500 for unknown error codes
		return httpStatus500, errorCodeDescription
	}
}

// toYAML converts an OpenAPI document to YAML format.
func (g *generator) toYAML(document *v3.Document) ([]byte, error) {
	if document == nil {
		return nil, errors.New(errorInvalidDocument)
	}

	// Use libopenapi's native Render method
	return document.Render()
}

// toJSON converts an OpenAPI document to JSON format.
func (g *generator) toJSON(document *v3.Document) ([]byte, error) {
	if document == nil {
		return nil, errors.New(errorInvalidDocument)
	}

	// Use libopenapi's native RenderJSON method
	return document.RenderJSON("  ")
}

// GenerateOpenAPI generates an OpenAPI 3.1 document from a specification.Service and writes it as JSON to the provided buffer.
// This is the main exported function following the same pattern as servergen.GenerateServer.
func GenerateOpenAPI(buf *bytes.Buffer, service *specification.Service) error {
	if service == nil {
		return errors.New(errorInvalidService)
	}

	// Create generator with default configuration
	generator := newGenerator()

	// Set basic configuration based on service
	generator.Title = service.Name + apiTitleSuffix
	generator.Description = defaultAPIDescription

	// Generate OpenAPI document
	document, err := generator.generateFromService(service)
	if err != nil {
		return fmt.Errorf("failed to generate OpenAPI document: %w", err)
	}

	// Convert to JSON
	jsonBytes, err := generator.toJSON(document)
	if err != nil {
		return fmt.Errorf("failed to convert OpenAPI document to JSON: %w", err)
	}

	// Write to buffer
	buf.Write(jsonBytes)

	return nil
}

// GenerateFromSpecificationToJSON is a convenience method that generates an OpenAPI document
// from a specification.Service and returns it as JSON in a single call.
// This method creates a generator with default settings, sets a standard title and description,
// generates the OpenAPI document, and converts it to JSON format.
// DEPRECATED: Use GenerateOpenAPI with a buffer instead. This is kept for backwards compatibility.
func GenerateFromSpecificationToJSON(service *specification.Service) ([]byte, error) {
	var buf bytes.Buffer
	err := GenerateOpenAPI(&buf, service)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// createRequestBodyReference creates a v3.RequestBody that renders as a reference to a component request body.
func (g *generator) createRequestBodyReference(resourceName, endpointName string) *v3.RequestBody {
	// Since v3.RequestBody doesn't directly support references, we use the Extensions field
	// with a $ref YAML node to create a reference that serializes properly
	requestBodyName := g.createRequestBodyName(resourceName, endpointName)
	refString := requestBodyReferencePrefix + requestBodyName

	// Create an extension map with a $ref node
	extensions := orderedmap.New[string, *yaml.Node]()
	extensions.Set("$ref", &yaml.Node{Kind: yaml.ScalarNode, Tag: "!!str", Value: refString})

	// Mark request body as required (default behavior for request bodies in operations)
	required := true

	// Return a request body that serializes as a reference with required field
	return &v3.RequestBody{
		Extensions: extensions,
		Required:   &required,
	}
}

// createErrorResponseReference creates a v3.Response that references a component error response.
func (g *generator) createErrorResponseReference(statusCode string, resourceName, endpointName string, hasBodyParams bool) *v3.Response {
	// Create reference to the appropriate component error response
	responseBodyName := errorResponseBodyPrefix + statusCode + responseBodySuffix
	refString := responseBodyReferencePrefix + responseBodyName

	// Create an extension map with a $ref node
	extensions := orderedmap.New[string, *yaml.Node]()
	extensions.Set("$ref", &yaml.Node{Kind: yaml.ScalarNode, Tag: "!!str", Value: refString})

	// Generate unique error description that includes operation name
	description := g.generateAutoErrorDescription(resourceName, endpointName, statusCode)

	// Return a response that serializes as a reference with unique description
	return &v3.Response{
		Description: description,
		Extensions:  extensions,
	}
}

// createEndpointSpecificErrorResponseReference creates a v3.Response that references an endpoint-specific error response (for 422).
func (g *generator) createEndpointSpecificErrorResponseReference(statusCode string, resourceName, endpointName string) *v3.Response {
	// Create reference to the endpoint-specific error response (e.g., EmployeeCreate422ResponseBody)
	responseBodyName := resourceName + endpointName + statusCode + responseBodySuffix
	refString := responseBodyReferencePrefix + responseBodyName

	// Create an extension map with a $ref node
	extensions := orderedmap.New[string, *yaml.Node]()
	extensions.Set("$ref", &yaml.Node{Kind: yaml.ScalarNode, Tag: "!!str", Value: refString})

	// Generate unique error description that includes operation name
	description := g.generateAutoErrorDescription(resourceName, endpointName, statusCode)

	// Return a response that serializes as a reference with unique description
	return &v3.Response{
		Description: description,
		Extensions:  extensions,
	}
}

// addSecuritySchemesToComponents adds security schemes from the service to the OpenAPI components.
func (g *generator) addSecuritySchemesToComponents(components *v3.Components, service *specification.Service) {
	if service.SecuritySchemes == nil {
		return
	}

	// Get sorted list of scheme names for deterministic iteration
	schemeNames := make([]string, 0, len(service.SecuritySchemes))
	for schemeName := range service.SecuritySchemes {
		schemeNames = append(schemeNames, schemeName)
	}
	sort.Strings(schemeNames)

	// Add security schemes in sorted order
	for _, schemeName := range schemeNames {
		scheme := service.SecuritySchemes[schemeName]
		securityScheme := g.createSecurityScheme(scheme)
		components.SecuritySchemes.Set(schemeName, securityScheme)
	}
}

// createSecurityScheme creates a v3.SecurityScheme from a specification.SecurityScheme.
func (g *generator) createSecurityScheme(scheme specification.SecurityScheme) *v3.SecurityScheme {
	securityScheme := &v3.SecurityScheme{
		Type:        scheme.Type,
		Description: scheme.Description,
	}

	// Set fields based on security scheme type
	switch scheme.Type {
	case securityTypeHTTP:
		securityScheme.Scheme = scheme.Scheme
		securityScheme.BearerFormat = scheme.BearerFormat
	case securityTypeAPIKey:
		securityScheme.Name = scheme.Name
		securityScheme.In = scheme.In
	}
	// mutualTLS type doesn't require additional fields

	return securityScheme
}

// addSecurityToDocument adds security requirements from the service to the OpenAPI document.
func (g *generator) addSecurityToDocument(document *v3.Document, service *specification.Service) {
	if len(service.Security) == 0 {
		return
	}

	// Convert simplified SecurityRequirement to base.SecurityRequirement
	securityRequirements := make([]*base.SecurityRequirement, len(service.Security))
	for i, requirement := range service.Security {
		securityRequirement := &base.SecurityRequirement{
			Requirements: orderedmap.New[string, []string](),
		}

		// Each requirement is a list of scheme names that must be satisfied together
		for _, schemeName := range requirement {
			securityRequirement.Requirements.Set(schemeName, []string{}) // Empty scopes for non-OAuth schemes
		}

		securityRequirements[i] = securityRequirement
	}

	document.Security = securityRequirements
}
