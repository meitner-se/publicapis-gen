package server

import (
	"bytes"
	"errors"
	"fmt"
	"io"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/meitner-se/publicapis-gen/specification"
	"github.com/meitner-se/publicapis-gen/specification/openapi"
	"github.com/oapi-codegen/oapi-codegen/v2/pkg/codegen"
)

// Error constants
const (
	errorInvalidDocument   = "invalid OpenAPI document: document cannot be nil"
	errorInvalidConfig     = "invalid generator configuration"
	errorCodegenFailed     = "code generation failed"
	errorDocumentRendering = "failed to render OpenAPI document"
)

// Default configuration constants
const (
	defaultPackageName = "api"
	defaultOutputFile  = "server.go"
)

// OpenAPI version constants
const (
	serverCompatibleOpenAPIVersion = "3.0.3" // Use 3.0.3 for better compatibility with code generators
)

// GeneratorConfig holds configuration for server code generation.
type GeneratorConfig struct {
	// PackageName specifies the Go package name for generated code
	PackageName string

	// OutputFile specifies the output file name for generated server code
	OutputFile string

	// GenerateTypes enables type definitions generation
	GenerateTypes bool

	// GenerateSpec enables embedded OpenAPI spec generation
	GenerateSpec bool
}

// NewDefaultConfig creates a GeneratorConfig with sensible defaults.
func NewDefaultConfig() GeneratorConfig {
	return GeneratorConfig{
		PackageName:   defaultPackageName,
		OutputFile:    defaultOutputFile,
		GenerateTypes: true, // Always generate types
		GenerateSpec:  true, // Include spec for documentation
	}
}

// Generator handles OpenAPI server code generation using oapi-codegen.
type Generator struct {
	config GeneratorConfig
}

// NewGenerator creates a new server code generator with the provided configuration.
func NewGenerator(config GeneratorConfig) *Generator {
	return &Generator{
		config: config,
	}
}

// GenerateFromDocument generates Go server code from OpenAPI document bytes.
func (g *Generator) GenerateFromDocument(docBytes []byte) ([]byte, error) {
	if docBytes == nil {
		return nil, errors.New(errorInvalidDocument)
	}

	// Load the OpenAPI document from JSON data
	doc, err := openapi3.NewLoader().LoadFromData(docBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse OpenAPI document: %w", err)
	}

	// Skip validation for now due to compatibility issues between libopenapi 3.1 features and kin-openapi 3.0 validation
	// The document is generated by a tested library, so validation should be safe to skip
	// ctx := context.Background()
	// if err := doc.Validate(ctx); err != nil {
	//     return nil, fmt.Errorf("OpenAPI document validation failed: %w", err)
	// }

	// Convert generator config to oapi-codegen configuration
	codegenConfig, err := g.createCodegenConfig()
	if err != nil {
		return nil, fmt.Errorf("%s: %w", errorInvalidConfig, err)
	}

	// Generate the server code
	serverCode, err := codegen.Generate(doc, codegenConfig)
	if err != nil {
		return nil, fmt.Errorf("%s: %w", errorCodegenFailed, err)
	}

	return []byte(serverCode), nil
}

// createCodegenConfig converts our GeneratorConfig to oapi-codegen's Configuration.
func (g *Generator) createCodegenConfig() (codegen.Configuration, error) {
	config := codegen.Configuration{
		PackageName: g.config.PackageName,
		Generate: codegen.GenerateOptions{
			GinServer:    true, // Hardcoded to use Gin framework
			Models:       g.config.GenerateTypes,
			EmbeddedSpec: g.config.GenerateSpec,
		},
		OutputOptions: codegen.OutputOptions{
			SkipFmt:   false,
			SkipPrune: false,
		},
	}

	// Validate configuration
	if config.PackageName == "" {
		return config, errors.New("package name cannot be empty")
	}

	return config, nil
}

// GenerateToWriter generates Go server code and writes it to the provided writer.
func (g *Generator) GenerateToWriter(docBytes []byte, writer io.Writer) error {
	code, err := g.GenerateFromDocument(docBytes)
	if err != nil {
		return err
	}

	_, err = writer.Write(code)
	return err
}

// GenerateToBuffer generates Go server code and writes it to a bytes buffer.
func (g *Generator) GenerateToBuffer(docBytes []byte) (*bytes.Buffer, error) {
	code, err := g.GenerateFromDocument(docBytes)
	if err != nil {
		return nil, err
	}

	buffer := bytes.NewBuffer(code)
	return buffer, nil
}

// ValidateConfig validates the generator configuration.
func (g *Generator) ValidateConfig() error {
	if g.config.PackageName == "" {
		return errors.New("package name cannot be empty")
	}

	if g.config.OutputFile == "" {
		return errors.New("output file cannot be empty")
	}

	return nil
}

// GenerateFromService generates Go server code from a specification.Service.
// This is the main entry point that handles the complete flow:
// Service -> OpenAPI document -> Server code.
func (g *Generator) GenerateFromService(service *specification.Service) ([]byte, error) {
	if service == nil {
		return nil, errors.New("invalid service: service cannot be nil")
	}

	// Generate OpenAPI document using the same method as standard OpenAPI generation
	openapiGenerator := &openapi.Generator{
		Version:     serverCompatibleOpenAPIVersion,
		Title:       service.Name + " API",
		Description: "Generated API documentation",
	}

	document, err := openapiGenerator.GenerateFromService(service)
	if err != nil {
		return nil, fmt.Errorf("failed to generate OpenAPI document: %w", err)
	}

	// Render the document to bytes
	docBytes, err := document.RenderJSON("  ")
	if err != nil {
		return nil, fmt.Errorf("failed to render OpenAPI document: %w", err)
	}

	// Generate server code from the document bytes
	return g.GenerateFromDocument(docBytes)
}
