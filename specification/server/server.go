package server

import (
	"bytes"
	"errors"
	"fmt"
	"io"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/oapi-codegen/v2/pkg/codegen"
	"github.com/pb33f/libopenapi/datamodel/high/v3"
)

// Error constants
const (
	errorInvalidDocument   = "invalid OpenAPI document: document cannot be nil"
	errorInvalidConfig     = "invalid generator configuration"
	errorCodegenFailed     = "code generation failed"
	errorDocumentRendering = "failed to render OpenAPI document"
)

// Default configuration constants
const (
	defaultPackageName = "api"
	defaultOutputFile  = "server.go"
)

// GeneratorConfig holds configuration for server code generation.
type GeneratorConfig struct {
	// PackageName specifies the Go package name for generated code
	PackageName string

	// OutputFile specifies the output file name for generated server code
	OutputFile string

	// GenerateEchoServer enables Echo framework server generation
	GenerateEchoServer bool

	// GenerateChiServer enables Chi framework server generation
	GenerateChiServer bool

	// GenerateGinServer enables Gin framework server generation
	GenerateGinServer bool

	// GenerateTypes enables type definitions generation
	GenerateTypes bool

	// GenerateSpec enables embedded OpenAPI spec generation
	GenerateSpec bool
}

// NewDefaultConfig creates a GeneratorConfig with sensible defaults.
func NewDefaultConfig() GeneratorConfig {
	return GeneratorConfig{
		PackageName:        defaultPackageName,
		OutputFile:         defaultOutputFile,
		GenerateEchoServer: true, // Echo is commonly used
		GenerateTypes:      true, // Always generate types
		GenerateSpec:       true, // Include spec for documentation
	}
}

// Generator handles OpenAPI server code generation using oapi-codegen.
type Generator struct {
	config GeneratorConfig
}

// NewGenerator creates a new server code generator with the provided configuration.
func NewGenerator(config GeneratorConfig) *Generator {
	return &Generator{
		config: config,
	}
}

// GenerateFromDocument generates Go server code from an OpenAPI v3 document.
func (g *Generator) GenerateFromDocument(document *v3.Document) ([]byte, error) {
	if document == nil {
		return nil, errors.New(errorInvalidDocument)
	}

	// Render the OpenAPI document to JSON (which is more reliable than YAML for parsing)
	docBytes, err := document.RenderJSON("  ")
	if err != nil {
		return nil, fmt.Errorf("%s: %w", errorDocumentRendering, err)
	}

	// Load the OpenAPI document from JSON data
	doc, err := openapi3.NewLoader().LoadFromData(docBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse OpenAPI document: %w", err)
	}

	// Skip validation for now due to compatibility issues between libopenapi 3.1 features and kin-openapi 3.0 validation
	// The document is generated by a tested library, so validation should be safe to skip
	// ctx := context.Background()
	// if err := doc.Validate(ctx); err != nil {
	//     return nil, fmt.Errorf("OpenAPI document validation failed: %w", err)
	// }

	// Convert generator config to oapi-codegen configuration
	codegenConfig, err := g.createCodegenConfig()
	if err != nil {
		return nil, fmt.Errorf("%s: %w", errorInvalidConfig, err)
	}

	// Generate the server code
	serverCode, err := codegen.Generate(doc, codegenConfig)
	if err != nil {
		return nil, fmt.Errorf("%s: %w", errorCodegenFailed, err)
	}

	return []byte(serverCode), nil
}

// createCodegenConfig converts our GeneratorConfig to oapi-codegen's Configuration.
func (g *Generator) createCodegenConfig() (codegen.Configuration, error) {
	config := codegen.Configuration{
		PackageName: g.config.PackageName,
		Generate: codegen.GenerateOptions{
			EchoServer:   g.config.GenerateEchoServer,
			ChiServer:    g.config.GenerateChiServer,
			GinServer:    g.config.GenerateGinServer,
			Models:       g.config.GenerateTypes,
			EmbeddedSpec: g.config.GenerateSpec,
		},
		OutputOptions: codegen.OutputOptions{
			SkipFmt:   false,
			SkipPrune: false,
		},
	}

	// Validate configuration
	if config.PackageName == "" {
		return config, errors.New("package name cannot be empty")
	}

	// Ensure at least one generation option is enabled
	if !config.Generate.EchoServer && !config.Generate.ChiServer &&
		!config.Generate.GinServer && !config.Generate.Models {
		return config, errors.New("at least one generation option must be enabled")
	}

	return config, nil
}

// GenerateToWriter generates Go server code and writes it to the provided writer.
func (g *Generator) GenerateToWriter(document *v3.Document, writer io.Writer) error {
	code, err := g.GenerateFromDocument(document)
	if err != nil {
		return err
	}

	_, err = writer.Write(code)
	return err
}

// GenerateToBuffer generates Go server code and writes it to a bytes buffer.
func (g *Generator) GenerateToBuffer(document *v3.Document) (*bytes.Buffer, error) {
	code, err := g.GenerateFromDocument(document)
	if err != nil {
		return nil, err
	}

	buffer := bytes.NewBuffer(code)
	return buffer, nil
}

// ValidateConfig validates the generator configuration.
func (g *Generator) ValidateConfig() error {
	if g.config.PackageName == "" {
		return errors.New("package name cannot be empty")
	}

	if g.config.OutputFile == "" {
		return errors.New("output file cannot be empty")
	}

	// Ensure at least one generation option is enabled
	if !g.config.GenerateEchoServer && !g.config.GenerateChiServer &&
		!g.config.GenerateGinServer && !g.config.GenerateTypes {
		return errors.New("at least one generation option must be enabled")
	}

	return nil
}
