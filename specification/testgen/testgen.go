package testgen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/aarondl/strmangle"
	"github.com/meitner-se/publicapis-gen/specification"
)

const (
	disclaimerComment = "// Code generated by publicapis-gen testgen. DO NOT EDIT.\n// This file is automatically generated from the API specification.\n// Any changes made to this file will be overwritten on the next generation.\n\n"
)

// GenerateInternalTests generates internal HTTP API tests from a service specification.
func GenerateInternalTests(buf *bytes.Buffer, service *specification.Service, packageName string) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports (no API package import needed for internal tests)
	err := generateInternalImports(buf)
	if err != nil {
		return err
	}

	// Generate test constants
	err = generateTestConstants(buf, service)
	if err != nil {
		return err
	}

	// Generate tests for each resource endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			err = generateInternalEndpointTest(buf, service, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	// Generate helper functions (no API package prefixes needed)
	err = generateInternalHelperFunctions(buf, service)
	if err != nil {
		return err
	}

	// Generate utility function tests (no API package prefixes needed)
	err = generateInternalUtilityTests(buf, service)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

// GenerateTests generates HTTP API tests from a service specification.
func GenerateTests(buf *bytes.Buffer, service *specification.Service, packageName string, apiPackageName string, apiPackageImport string) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports
	err := generateImports(buf, apiPackageName, apiPackageImport)
	if err != nil {
		return err
	}

	// Generate test constants
	err = generateTestConstants(buf, service)
	if err != nil {
		return err
	}

	// Generate tests for each resource endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			err = generateEndpointTest(buf, service, resource, endpoint, apiPackageName)
			if err != nil {
				return err
			}
		}
	}

	// Generate helper functions
	err = generateHelperFunctions(buf, service, apiPackageName)
	if err != nil {
		return err
	}

	// Generate utility function tests
	err = generateUtilityTests(buf, service, apiPackageName)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

// generateInternalImports generates the import section for internal test files.
func generateInternalImports(buf *bytes.Buffer) error {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString("\t\"testing\"\n\n")
	buf.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString("\t\"github.com/meitner-se/go-types\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/assert\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateImports generates the import section for the test file.
func generateImports(buf *bytes.Buffer, apiPackageName string, apiPackageImport string) error {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString("\t\"testing\"\n\n")
	buf.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString("\t\"github.com/meitner-se/go-types\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/assert\"\n")
	if apiPackageImport != "" {
		if apiPackageName != "" && apiPackageName != "api" {
			buf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", apiPackageName, apiPackageImport))
		} else {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", apiPackageImport))
		}
	}
	buf.WriteString(")\n\n")

	return nil
}

// generateTestConstants generates constants used across tests.
func generateTestConstants(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// Test constants\n")
	buf.WriteString("const (\n")
	buf.WriteString("\ttestRequestID = \"test-request-id-123\"\n")
	buf.WriteString("\ttestSessionUserID = \"test-session-user-id\"\n")
	buf.WriteString("\ttestTimeout = \"30s\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateEndpointTest generates a test function for a specific endpoint.
func generateEndpointTest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	serviceName := strmangle.TitleCase(service.Name)
	testName := fmt.Sprintf("Test%s%s", resource.Name, endpoint.Name)

	buf.WriteString(fmt.Sprintf("// %s tests the %s endpoint for %s\n", testName, endpoint.Name, resource.Name))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testName))
	buf.WriteString("\tt.Run(\"Request\", func(t *testing.T) {\n")

	// Generate test setup (without parameters)
	err := generateTestSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate mock setup
	err = generateMockSetup(buf, service, resource, endpoint, apiPackageName)
	if err != nil {
		return err
	}

	// Generate server setup
	err = generateServerSetup(buf, serviceName, service, resource, endpoint, apiPackageName)
	if err != nil {
		return err
	}

	// Generate HTTP request (with parameters defined inline)
	err = generateHTTPRequest(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate assertions
	err = generateAssertions(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateTestSetup generates the test setup section.
func generateTestSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Arrange\n")
	buf.WriteString("\t\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\t\tctx := context.Background()\n\n")

	return nil
}

// generateTestParameterValue generates a test value for a parameter.
func generateTestParameterValue(buf *bytes.Buffer, param specification.Field, paramType string) error {
	varName := fmt.Sprintf("test%s%s", strmangle.TitleCase(paramType), strmangle.TitleCase(param.Name))

	switch param.Type {
	case "UUID":
		buf.WriteString(fmt.Sprintf("\t\t%s := uuid.New().String()\n", varName))
	case "String":
		defaultValue := "test-value"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	case "Int":
		defaultValue := "123"
		if param.Example != "" {
			defaultValue = param.Example
		}
		// Use float64 for consistency with JSON unmarshaling
		buf.WriteString(fmt.Sprintf("\t\t%s := float64(%s)\n", varName, defaultValue))
	case "Bool":
		defaultValue := "true"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := %s\n", varName, defaultValue))
	case "Date":
		defaultValue := "2024-01-15"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	case "Timestamp":
		defaultValue := "2024-01-15T10:30:00Z"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	default:
		// For custom types, generate a basic string value
		buf.WriteString(fmt.Sprintf("\t\t%s := \"test-%s-value\"\n", varName, strings.ToLower(param.Name)))
	}

	return nil
}

// generateTestBody generates test data for request body.
func generateTestBody(buf *bytes.Buffer, bodyParams []specification.Field, service *specification.Service) error {
	buf.WriteString("\t\ttestBody := map[string]interface{}{\n")

	for _, param := range bodyParams {
		jsonKey := getJSONKey(param.Name)

		if param.IsArray() {
			// Handle array types
			switch param.Type {
			case "UUID":
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{uuid.New().String()},\n", jsonKey))
			case "String":
				defaultValue := "test-value"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			case "Int":
				defaultValue := "123"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{float64(%s)},\n", jsonKey, defaultValue))
			case "Bool":
				defaultValue := "true"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{%s},\n", jsonKey, defaultValue))
			case "Date":
				defaultValue := "2024-01-15"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			case "Timestamp":
				defaultValue := "2024-01-15T10:30:00Z"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			default:
				// For custom object arrays, create an array with one test object
				if service.IsObject(param.Type) {
					visited := make(map[string]bool)
					objectFields := getObjectTestDataWithVisited(param.Type, service, visited)
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{map[string]interface{}{%s}},\n", jsonKey, objectFields))
				} else {
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"test-%s-value\"},\n", jsonKey, strings.ToLower(param.Name)))
				}
			}
		} else {
			// Handle single value types
			switch param.Type {
			case "UUID":
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": uuid.New().String(),\n", jsonKey))
			case "String":
				defaultValue := "test-value"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			case "Int":
				defaultValue := "123"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": float64(%s),\n", jsonKey, defaultValue))
			case "Bool":
				defaultValue := "true"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": %s,\n", jsonKey, defaultValue))
			case "Date":
				defaultValue := "2024-01-15"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			case "Timestamp":
				defaultValue := "2024-01-15T10:30:00Z"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			default:
				// For custom object types, create a nested object
				if service.IsObject(param.Type) {
					visited := make(map[string]bool)
					objectFields := getObjectTestDataWithVisited(param.Type, service, visited)
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": map[string]interface{}{%s},\n", jsonKey, objectFields))
				} else {
					// For enums or unknown types, use string
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"test-%s-value\",\n", jsonKey, strings.ToLower(param.Name)))
				}
			}
		}
	}

	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\ttestBodyBytes, err := json.Marshal(testBody)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal test body\")\n")

	return nil
}

// generateMockSetup generates mock service setup that captures the request for parameter validation.
func generateMockSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	buf.WriteString("\t\t// Mock service setup\n")
	buf.WriteString(fmt.Sprintf("\t\tvar capturedRequest %s.Request[any, %s, %s, %s]\n",
		apiPackageName,
		getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
		getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
		getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))

	// The mock configuration is now handled in generateServerSetup
	// This function just declares the captured request variable

	return nil
}

// generateServerSetup generates HTTP server setup.
func generateServerSetup(buf *bytes.Buffer, serviceName string, service *specification.Service, currentResource specification.Resource, currentEndpoint specification.Endpoint, apiPackageName string) error {
	buf.WriteString("\t\t// Server setup\n")
	buf.WriteString("\t\trouter := gin.New()\n")

	// Create and configure only the mock for the resource being tested
	buf.WriteString(fmt.Sprintf("\t\tmock%sAPI := &Mock%sAPI{}\n", currentResource.Name, currentResource.Name))

	methodName := currentEndpoint.Name
	if currentEndpoint.HasResponseType() {
		responseType := currentEndpoint.GetResponseType(currentResource.Name)
		buf.WriteString(fmt.Sprintf("\t\texpected%s := &%s.%s{\n", responseType, apiPackageName, responseType))
		buf.WriteString("\t\t\t// Add expected response fields here based on your needs\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error) {\n",
			currentResource.Name, methodName, apiPackageName,
			getAPITypeReference(currentEndpoint.GetPathParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name), apiPackageName),
			apiPackageName, responseType))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString(fmt.Sprintf("\t\t\treturn expected%s, nil\n", responseType))
		buf.WriteString("\t\t}\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s.Request[any, %s, %s, %s]) error {\n",
			currentResource.Name, methodName, apiPackageName,
			getAPITypeReference(currentEndpoint.GetPathParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name), apiPackageName)))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString("\t\t\treturn nil\n")
		buf.WriteString("\t\t}\n")
	}
	buf.WriteString("\n")

	buf.WriteString(fmt.Sprintf("\t\t%s.Register%sAPI(router, &%s.%sAPI[any]{\n", apiPackageName, serviceName, apiPackageName, serviceName))
	buf.WriteString(fmt.Sprintf("\t\t\tServer: %s.Server[any]{\n", apiPackageName))
	buf.WriteString("\t\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\t\treturn testSessionUserID, nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString(fmt.Sprintf("\t\t\t\tErrorHook: func(ctx context.Context, requestContext %s.RequestContext, err error) *%s.Error {\n", apiPackageName, apiPackageName))
	buf.WriteString(fmt.Sprintf("\t\t\t\t\treturn &%s.Error{\n", apiPackageName))
	buf.WriteString(fmt.Sprintf("\t\t\t\t\t\tCode:      %s.ErrorCodeInternal,\n", apiPackageName))
	buf.WriteString("\t\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t\t}\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")

	// Add all resource mocks to the API struct
	for _, resource := range service.Resources {
		if len(resource.Endpoints) > 0 {
			if resource.Name == currentResource.Name {
				// Use the configured mock for the resource being tested
				buf.WriteString(fmt.Sprintf("\t\t\t%s: mock%sAPI,\n", resource.Name, resource.Name))
			} else {
				// Create inline mocks for other resources to prevent panics
				buf.WriteString(fmt.Sprintf("\t\t\t%s: &Mock%sAPI{},\n", resource.Name, resource.Name))
			}
		}
	}

	buf.WriteString("\t\t})\n")
	buf.WriteString("\t\tserver := httptest.NewServer(router)\n")
	buf.WriteString("\t\tdefer server.Close()\n\n")

	return nil
}

// generateHTTPRequest generates the HTTP request execution.
func generateHTTPRequest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Act - Execute HTTP request\n")

	// Build URL
	path := endpoint.GetFullPath(resource.Name)
	buf.WriteString(fmt.Sprintf("\t\trequestURL := server.URL + \"/%s/%s%s\"\n", service.PathName(), service.Version, path))

	// Generate and use path parameters
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Path parameters\n")
		for _, param := range endpoint.Request.PathParams {
			err := generateTestParameterValue(buf, param, "path")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")

		// Replace path parameters in URL
		for _, param := range endpoint.Request.PathParams {
			paramName := fmt.Sprintf("{%s}", strings.ToLower(param.Name))
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			buf.WriteString(fmt.Sprintf("\t\trequestURL = strings.ReplaceAll(requestURL, \"%s\", %s)\n", paramName, varName))
		}
		buf.WriteString("\n")
	}

	// Generate and use query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Query parameters\n")
		for _, param := range endpoint.Request.QueryParams {
			err := generateTestParameterValue(buf, param, "query")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")

		buf.WriteString("\t\t// Add query parameters to URL\n")
		buf.WriteString("\t\tquery := url.Values{}\n")
		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tquery.Add(\"%s\", fmt.Sprintf(\"%%v\", %s))\n", jsonKey, varName))
		}
		buf.WriteString("\t\tif len(query) > 0 {\n")
		buf.WriteString("\t\t\trequestURL += \"?\" + query.Encode()\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\n")
	}

	// Generate and use body parameters
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Body parameters\n")
		err := generateTestBody(buf, endpoint.Request.BodyParams, service)
		if err != nil {
			return err
		}
		buf.WriteString("\n")
	}

	// Create request
	method := strings.ToUpper(endpoint.Method)
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, bytes.NewBuffer(testBodyBytes))\n", method))
	} else {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, nil)\n", method))
	}

	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create HTTP request\")\n")

	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	}

	// Execute request
	buf.WriteString("\t\tresp, err := http.DefaultClient.Do(req)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to execute HTTP request\")\n")
	buf.WriteString("\t\tdefer resp.Body.Close()\n\n")

	return nil
}

// generateAssertions generates test assertions.
func generateAssertions(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Assert\n")
	buf.WriteString("\t\t// Read response body for debugging and verification\n")
	buf.WriteString("\t\tresponseBodyBytes, err := io.ReadAll(resp.Body)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to read response body\")\n\n")

	buf.WriteString("\t\t// Check status code and print response body if unexpected\n")
	buf.WriteString("\t\tif resp.StatusCode != " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + " {\n")
	buf.WriteString("\t\t\tt.Errorf(\"Expected HTTP status %d, got %d. Response body: %s\", " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + ", resp.StatusCode, string(responseBodyBytes))\n")
	buf.WriteString("\t\t\treturn\n")
	buf.WriteString("\t\t}\n\n")

	if endpoint.HasResponseType() {
		buf.WriteString("\t\t// Verify response body\n")
		buf.WriteString("\t\tvar responseBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(responseBodyBytes, &responseBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to decode response body\")\n")
		buf.WriteString("\t\tassert.NotNil(t, responseBody, \"Response body should not be nil\")\n")
	}

	// Verify the service method was called with the request
	buf.WriteString("\t\t// Verify service method was called (indicating HTTP request was processed)\n")
	buf.WriteString("\t\tassert.NotNil(t, capturedRequest, \"Service method should have been called with a request\")\n\n")

	// Assert path parameters by converting to JSON for easy comparison
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Verify path parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedPathBytes, err := json.Marshal(capturedRequest.PathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured path params\")\n")
		buf.WriteString("\t\tvar capturedPathParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedPathBytes, &capturedPathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured path params\")\n\n")

		for _, param := range endpoint.Request.PathParams {
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedPathParams[\"%s\"], \"Path parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert query parameters by converting to JSON for easy comparison
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Verify query parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedQueryBytes, err := json.Marshal(capturedRequest.QueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured query params\")\n")
		buf.WriteString("\t\tvar capturedQueryParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedQueryBytes, &capturedQueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured query params\")\n\n")

		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedQueryParams[\"%s\"], \"Query parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert body parameters by converting captured request body to JSON for easy comparison
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Verify body parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedBodyBytes, err := json.Marshal(capturedRequest.BodyParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured body params\")\n")
		buf.WriteString("\t\tvar capturedRequestBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedBodyBytes, &capturedRequestBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured body params\")\n\n")

		for _, param := range endpoint.Request.BodyParams {
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequestBody[\"%s\"], \"Body parameter %s should match\")\n",
				jsonKey, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateHelperFunctions generates helper functions and mock interfaces.
func generateHelperFunctions(buf *bytes.Buffer, service *specification.Service, apiPackageName string) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Mock interfaces and helper functions\n")
	buf.WriteString("// ============================================================================\n\n")

	// Generate mock interfaces for each resource
	for _, resource := range service.Resources {
		if len(resource.Endpoints) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("// Mock%sAPI is a mock implementation of %sAPI\n", resource.Name, resource.Name))
		buf.WriteString(fmt.Sprintf("type Mock%sAPI struct {\n", resource.Name))

		// Generate function fields for each endpoint
		for _, endpoint := range resource.Endpoints {
			methodName := endpoint.Name

			if endpoint.HasResponseType() {
				responseType := endpoint.GetResponseType(resource.Name)
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error)\n",
					methodName, apiPackageName,
					getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName),
					apiPackageName, responseType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s.Request[any, %s, %s, %s]) error\n",
					methodName, apiPackageName,
					getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))
			}
		}

		buf.WriteString("}\n\n")

		// Generate mock methods for each endpoint
		for _, endpoint := range resource.Endpoints {
			err := generateMockMethod(buf, resource, endpoint, apiPackageName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// generateMockMethod generates a mock method for an endpoint.
func generateMockMethod(buf *bytes.Buffer, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	methodName := endpoint.Name

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error) {\n",
			resource.Name, methodName, apiPackageName,
			getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName),
			apiPackageName, responseType))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil, nil\n")
	} else {
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s.Request[any, %s, %s, %s]) error {\n",
			resource.Name, methodName, apiPackageName,
			getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil\n")
	}

	buf.WriteString("}\n\n")

	return nil
}

// getAPITypeReference adds the API package prefix to type names, except for built-in types like struct{}.
func getAPITypeReference(typeName string, apiPackageName string) string {
	if typeName == "struct{}" {
		return "struct{}"
	}
	return apiPackageName + "." + typeName
}

// getObjectTestDataWithVisited generates test data for a custom object type with recursion protection.
func getObjectTestDataWithVisited(objectType string, service *specification.Service, visited map[string]bool) string {
	// Check for circular references
	if visited[objectType] {
		return "" // Avoid infinite recursion - return empty string for truly empty object
	}
	visited[objectType] = true

	// Find the object definition
	for _, obj := range service.Objects {
		if obj.Name == objectType {
			var fields []string
			for _, field := range obj.Fields {
				jsonKey := getJSONKey(field.Name)

				// Include nullable fields with nil values to match JSON marshaling behavior
				if field.IsNullable() {
					fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": nil", jsonKey))
					continue
				}

				if field.IsArray() {
					// Handle array fields in objects
					switch field.Type {
					case "UUID":
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{uuid.New().String()}", jsonKey))
					case "String":
						defaultValue := "test-value"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					case "Int":
						defaultValue := "123"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{float64(%s)}", jsonKey, defaultValue))
					case "Bool":
						defaultValue := "true"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{%s}", jsonKey, defaultValue))
					case "Date":
						defaultValue := "2024-01-15"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					case "Timestamp":
						defaultValue := "2024-01-15T10:30:00Z"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					default:
						// For custom object arrays, create an array with one test object
						if service.IsObject(field.Type) {
							nestedObjectFields := getObjectTestDataWithVisited(field.Type, service, visited)
							if nestedObjectFields != "" {
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{map[string]interface{}{%s}}", jsonKey, nestedObjectFields))
							} else {
								// For circular references, create empty array
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{}", jsonKey))
							}
						} else {
							fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"test-%s-value\"}", jsonKey, strings.ToLower(field.Name)))
						}
					}
				} else {
					// Handle single value fields in objects
					switch field.Type {
					case "UUID":
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": uuid.New().String()", jsonKey))
					case "String":
						defaultValue := "test-value"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					case "Int":
						defaultValue := "123"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": float64(%s)", jsonKey, defaultValue))
					case "Bool":
						defaultValue := "true"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": %s", jsonKey, defaultValue))
					case "Date":
						defaultValue := "2024-01-15"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					case "Timestamp":
						defaultValue := "2024-01-15T10:30:00Z"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					default:
						// For nested objects, create proper object structure recursively
						if service.IsObject(field.Type) {
							nestedObjectFields := getObjectTestDataWithVisited(field.Type, service, visited)
							if nestedObjectFields != "" {
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": map[string]interface{}{%s}", jsonKey, nestedObjectFields))
							}
							// Skip circular references entirely - don't add field at all
						} else {
							// For enums, use string for simplicity
							fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"test-%s-value\"", jsonKey, strings.ToLower(field.Name)))
						}
					}
				}
			}

			if len(fields) > 0 {
				return strings.Join(fields, ",") + ",\n\t\t\t"
			}
			return ""
		}
	}

	// If object not found, return empty
	return ""
}

// generateUtilityTests generates tests for utility functions.
func generateUtilityTests(buf *bytes.Buffer, service *specification.Service, apiPackageName string) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Utility function tests\n")
	buf.WriteString("// ============================================================================\n\n")

	// Test serveWithResponse
	err := generateServeWithResponseTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test serveWithoutResponse
	err = generateServeWithoutResponseTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test handleRequest
	err = generateHandleRequestTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test decodeBodyParams
	err = generateDecodeBodyParamsTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test decodePathParams
	err = generateDecodePathParamsTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test decodeQueryParams
	err = generateDecodeQueryParamsTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test PreHooks functionality
	err = generatePreHookTests(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test SessionHooks functionality
	err = generateSessionHookTests(buf, apiPackageName)
	if err != nil {
		return err
	}

	return nil
}

// generateServeWithResponseTest generates test for serveWithResponse function.
func generateServeWithResponseTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_serveWithResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that returns a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithResponse\n")
	buf.WriteString("\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\tassert.Contains(t, w.Body.String(), \"success\", \"Expected success message\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateServeWithoutResponseTest generates test for serveWithoutResponse function.
func generateServeWithoutResponseTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_serveWithoutResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that doesn't return a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[any, struct{}, struct{}, struct{}]) error {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithoutResponse\n")
	buf.WriteString("\thandler := " + apiPackageName + ".ServeWithoutResponse(204, server, mockFunction)\n")
	buf.WriteString("\trouter.DELETE(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"DELETE\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 204, w.Code, \"Expected 204 status code\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateHandleRequestTest generates test for handleRequest function.
func generateHandleRequestTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_handleRequest(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	buf.WriteString("\tt.Run(\"successful request parsing\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n\n")

	buf.WriteString("\t\t// Create test request with JSON body\n")
	buf.WriteString("\t\ttestBody := `{\"name\": \"test\"}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test?limit=10&offset=0\", strings.NewReader(testBody))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n")
	buf.WriteString("\t\tc.Params = []gin.Param{{Key: \"id\", Value: \"123\"}}\n\n")

	buf.WriteString("\t\t// Create test server\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest\n")
	buf.WriteString("\t\trequestContext := " + apiPackageName + ".getRequestContext(c, \"test-123\")\n")
	buf.WriteString("\t\trequest, apiError := " + apiPackageName + ".handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.Nil(t, apiError, \"Expected no error from handleRequest\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-session\", request.Session, \"Session should be set\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-123\", request.Context().RequestID, \"RequestID should be set\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"session function error returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Create test server with session function that returns error\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn nil, fmt.Errorf(\"authentication failed\")\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with session error\n")
	buf.WriteString("\t\trequestContext := " + apiPackageName + ".getRequestContext(c, \"test-456\")\n")
	buf.WriteString("\t\t_, err = " + apiPackageName + ".handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.NotNil(t, err, \"Expected API error when session function fails\")\n")
	buf.WriteString("\t\tapiError, ok := err.(*" + apiPackageName + ".Error)\n")
	buf.WriteString("\t\tassert.True(t, ok, \"Error should be of type *Error\")\n")
	buf.WriteString("\t\tassert.Equal(t, " + apiPackageName + ".ErrorCodeUnauthorized, apiError.Code, \"Should return Unauthorized error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"authentication failed\", \"Error message should contain session error\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-456\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"invalid JSON body returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\t// Define test struct for body params\n")
	buf.WriteString("\t\ttype TestBodyParams struct {\n")
	buf.WriteString("\t\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\tinvalidJSON := `{\"name\": invalid json}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(invalidJSON))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Create test server\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with invalid JSON\n")
	buf.WriteString("\t\trequestContext := " + apiPackageName + ".getRequestContext(c, \"test-789\")\n")
	buf.WriteString("\t\t_, err = " + apiPackageName + ".handleRequest[any, struct{}, struct{}, TestBodyParams](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.NotNil(t, err, \"Expected API error when JSON is invalid\")\n")
	buf.WriteString("\t\tapiError, ok := err.(*" + apiPackageName + ".Error)\n")
	buf.WriteString("\t\tassert.True(t, ok, \"Error should be of type *Error\")\n")
	buf.WriteString("\t\tassert.Equal(t, " + apiPackageName + ".ErrorCodeBadRequest, apiError.Code, \"Should return BadRequest error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"cannot decode json body params\", \"Error message should mention JSON decoding\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-789\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"pre-hooks are executed in handleRequest\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\tvar hookExecuted bool\n")
	buf.WriteString("\t\tvar capturedContext " + apiPackageName + ".RequestContext\n\n")

	buf.WriteString("\t\t// Create test server with pre-hook\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []" + apiPackageName + ".PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\thookExecuted = true\n")
	buf.WriteString("\t\t\t\t\tcapturedContext = requestContext\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with pre-hook\n")
	buf.WriteString("\t\trequestContext := " + apiPackageName + ".getRequestContext(c, \"test-prehook\")\n")
	buf.WriteString("\t\t_, apiError := " + apiPackageName + ".handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.Nil(t, apiError, \"Expected no error from handleRequest\")\n")
	buf.WriteString("\t\tassert.True(t, hookExecuted, \"Pre-hook should have been executed\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-prehook\", capturedContext.RequestID, \"Pre-hook should receive correct RequestID\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test\", capturedContext.Path, \"Pre-hook should receive correct Path\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"pre-hook error aborts handleRequest\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Create test server with pre-hook that returns error\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeForbidden,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []" + apiPackageName + ".PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\treturn fmt.Errorf(\"pre-hook validation failed\")\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with pre-hook error\n")
	buf.WriteString("\t\trequestContext := " + apiPackageName + ".getRequestContext(c, \"test-prehook-error\")\n")
	buf.WriteString("\t\t_, err = " + apiPackageName + ".handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.NotNil(t, err, \"Expected API error when pre-hook fails\")\n")
	buf.WriteString("\t\tassert.Contains(t, err.Error(), \"pre-hook validation failed\", \"Error message should contain pre-hook error\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"session-hooks are executed after authentication\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\tvar sessionHookExecuted bool\n")
	buf.WriteString("\t\tvar capturedSession string\n")
	buf.WriteString("\t\tvar capturedContext " + apiPackageName + ".RequestContext\n\n")

	buf.WriteString("\t\t// Create test server with session hook\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session-123\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []" + apiPackageName + ".SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\tsessionHookExecuted = true\n")
	buf.WriteString("\t\t\t\t\tcapturedSession = session\n")
	buf.WriteString("\t\t\t\t\tcapturedContext = requestContext\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test parseRequest with session hook\n")
	buf.WriteString("\t\trequest, apiError := " + apiPackageName + ".ParseRequest[string, struct{}, struct{}, struct{}](c, \"test-sessionhook\", server)\n")
	buf.WriteString("\t\tassert.Nil(t, apiError, \"Expected no error from parseRequest\")\n")
	buf.WriteString("\t\tassert.True(t, sessionHookExecuted, \"Session hook should have been executed\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-session-123\", capturedSession, \"Session hook should receive correct session\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-sessionhook\", capturedContext.RequestID, \"Session hook should receive correct RequestID\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-session-123\", request.Session, \"Request should contain the session\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"session-hook error aborts request\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Create test server with session hook that returns error\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeForbidden,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []" + apiPackageName + ".SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\treturn fmt.Errorf(\"insufficient permissions\")\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with session hook error\n")
	buf.WriteString("\t\trequestContext := " + apiPackageName + ".getRequestContext(c, \"test-sessionhook-error\")\n")
	buf.WriteString("\t\t_, err = " + apiPackageName + ".handleRequest[string, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.NotNil(t, err, \"Expected API error when session hook fails\")\n")
	buf.WriteString("\t\tassert.Contains(t, err.Error(), \"insufficient permissions\", \"Error message should contain session hook error\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateDecodeBodyParamsTest generates test for decodeBodyParams function.
func generateDecodeBodyParamsTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_decodeBodyParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestBody struct {\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\tAge  int    `json:\"age\"`\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\ttestBody := `{\"name\": \"test\", \"age\": 25}`\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(testBody))\n")
	buf.WriteString("\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n\n")

	buf.WriteString("\t// Test decodeBodyParams\n")
	buf.WriteString("\tresult, err := " + apiPackageName + ".DecodeBodyParams[TestBody](req)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeBodyParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 25, result.Age, \"Age should be decoded as int\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateDecodePathParamsTest generates test for decodePathParams function.
func generateDecodePathParamsTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_decodePathParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestPathParams struct {\n")
	buf.WriteString("\t\tID   string `json:\"id\"`\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\tc.Params = []gin.Param{\n")
	buf.WriteString("\t\t{Key: \"id\", Value: \"123\"},\n")
	buf.WriteString("\t\t{Key: \"name\", Value: \"test\"},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Test decodePathParams\n")
	buf.WriteString("\tresult, err := " + apiPackageName + ".DecodePathParams[TestPathParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodePathParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"123\", result.ID, \"ID should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateDecodeQueryParamsTest generates test for decodeQueryParams function.
func generateDecodeQueryParamsTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_decodeQueryParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestQueryParams struct {\n")
	buf.WriteString("\t\tLimit  int  `form:\"limit\"`\n")
	buf.WriteString("\t\tOffset int  `form:\"offset\"`\n")
	buf.WriteString("\t\tActive bool `form:\"active\"`\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\treq, err := http.NewRequest(\"GET\", \"/test?limit=10&offset=0&active=true\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tc.Request = req\n\n")

	buf.WriteString("\t// Test decodeQueryParams\n")
	buf.WriteString("\tresult, err := " + apiPackageName + ".DecodeQueryParams[TestQueryParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeQueryParams\")\n")
	buf.WriteString("\tassert.Equal(t, 10, result.Limit, \"Limit should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 0, result.Offset, \"Offset should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, true, result.Active, \"Active should be decoded\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateInternalEndpointTest generates an internal test function for a specific endpoint.
func generateInternalEndpointTest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	serviceName := strmangle.TitleCase(service.Name)
	testName := fmt.Sprintf("Test%s%s", resource.Name, endpoint.Name)

	buf.WriteString(fmt.Sprintf("// %s tests the %s endpoint for %s\n", testName, endpoint.Name, resource.Name))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testName))
	buf.WriteString("\tt.Run(\"Request\", func(t *testing.T) {\n")

	// Generate test setup (without parameters)
	err := generateTestSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate internal mock setup (no package prefixes)
	err = generateInternalMockSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate internal server setup (no package prefixes)
	err = generateInternalServerSetup(buf, serviceName, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate HTTP request (with parameters defined inline)
	err = generateHTTPRequest(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate internal assertions (no package prefixes)
	err = generateInternalAssertions(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateInternalMockSetup generates internal mock service setup.
func generateInternalMockSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Mock service setup\n")
	buf.WriteString(fmt.Sprintf("\t\tvar capturedRequest Request[any, %s, %s, %s]\n",
		getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
		getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
		getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name))))

	// The mock configuration is now handled in generateInternalServerSetup
	// This function just declares the captured request variable

	return nil
}

// generateInternalServerSetup generates internal HTTP server setup.
func generateInternalServerSetup(buf *bytes.Buffer, serviceName string, service *specification.Service, currentResource specification.Resource, currentEndpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Server setup\n")
	buf.WriteString("\t\trouter := gin.New()\n")

	// Create and configure only the mock for the resource being tested
	buf.WriteString(fmt.Sprintf("\t\tmock%sAPI := &Mock%sAPI{}\n", currentResource.Name, currentResource.Name))

	methodName := currentEndpoint.Name
	if currentEndpoint.HasResponseType() {
		responseType := currentEndpoint.GetResponseType(currentResource.Name)
		buf.WriteString(fmt.Sprintf("\t\texpected%s := &%s{\n", responseType, responseType))
		buf.WriteString("\t\t\t// Add expected response fields here based on your needs\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request Request[any, %s, %s, %s]) (*%s, error) {\n",
			currentResource.Name, methodName,
			getInternalTypeReference(currentEndpoint.GetPathParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name)),
			responseType))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString(fmt.Sprintf("\t\t\treturn expected%s, nil\n", responseType))
		buf.WriteString("\t\t}\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request Request[any, %s, %s, %s]) error {\n",
			currentResource.Name, methodName,
			getInternalTypeReference(currentEndpoint.GetPathParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name))))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString("\t\t\treturn nil\n")
		buf.WriteString("\t\t}\n")
	}
	buf.WriteString("\n")

	buf.WriteString(fmt.Sprintf("\t\tRegister%sAPI(router, &%sAPI[any]{\n", serviceName, serviceName))
	buf.WriteString("\t\t\tServer: Server[any]{\n")
	buf.WriteString("\t\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\t\treturn testSessionUserID, nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t\t}\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")

	// Add all resource mocks to the API struct
	for _, resource := range service.Resources {
		if len(resource.Endpoints) > 0 {
			if resource.Name == currentResource.Name {
				// Use the configured mock for the resource being tested
				buf.WriteString(fmt.Sprintf("\t\t\t%s: mock%sAPI,\n", resource.Name, resource.Name))
			} else {
				// Create inline mocks for other resources to prevent panics
				buf.WriteString(fmt.Sprintf("\t\t\t%s: &Mock%sAPI{},\n", resource.Name, resource.Name))
			}
		}
	}

	buf.WriteString("\t\t})\n")
	buf.WriteString("\t\tserver := httptest.NewServer(router)\n")
	buf.WriteString("\t\tdefer server.Close()\n\n")

	return nil
}

// generateInternalAssertions generates internal test assertions.
func generateInternalAssertions(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Assert\n")
	buf.WriteString("\t\t// Read response body for debugging and verification\n")
	buf.WriteString("\t\tresponseBodyBytes, err := io.ReadAll(resp.Body)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to read response body\")\n\n")

	buf.WriteString("\t\t// Check status code and print response body if unexpected\n")
	buf.WriteString("\t\tif resp.StatusCode != " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + " {\n")
	buf.WriteString("\t\t\tt.Errorf(\"Expected HTTP status %d, got %d. Response body: %s\", " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + ", resp.StatusCode, string(responseBodyBytes))\n")
	buf.WriteString("\t\t\treturn\n")
	buf.WriteString("\t\t}\n\n")

	if endpoint.HasResponseType() {
		buf.WriteString("\t\t// Verify response body\n")
		buf.WriteString("\t\tvar responseBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(responseBodyBytes, &responseBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to decode response body\")\n")
		buf.WriteString("\t\tassert.NotNil(t, responseBody, \"Response body should not be nil\")\n")
	}

	// Verify the service method was called with the request
	buf.WriteString("\t\t// Verify service method was called (indicating HTTP request was processed)\n")
	buf.WriteString("\t\tassert.NotNil(t, capturedRequest, \"Service method should have been called with a request\")\n\n")

	// Add parameter assertions using JSON conversion (same as external tests)
	// Assert path parameters by converting to JSON for easy comparison
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Verify path parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedPathBytes, err := json.Marshal(capturedRequest.PathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured path params\")\n")
		buf.WriteString("\t\tvar capturedPathParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedPathBytes, &capturedPathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured path params\")\n\n")

		for _, param := range endpoint.Request.PathParams {
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedPathParams[\"%s\"], \"Path parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert query parameters by converting to JSON for easy comparison
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Verify query parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedQueryBytes, err := json.Marshal(capturedRequest.QueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured query params\")\n")
		buf.WriteString("\t\tvar capturedQueryParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedQueryBytes, &capturedQueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured query params\")\n\n")

		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedQueryParams[\"%s\"], \"Query parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert body parameters by converting captured request body to JSON for easy comparison
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Verify body parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedBodyBytes, err := json.Marshal(capturedRequest.BodyParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured body params\")\n")
		buf.WriteString("\t\tvar capturedRequestBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedBodyBytes, &capturedRequestBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured body params\")\n\n")

		for _, param := range endpoint.Request.BodyParams {
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequestBody[\"%s\"], \"Body parameter %s should match\")\n",
				jsonKey, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateInternalHelperFunctions generates internal helper functions and mock interfaces.
func generateInternalHelperFunctions(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Mock interfaces and helper functions\n")
	buf.WriteString("// ============================================================================\n\n")

	// Generate mock interfaces for each resource (no package prefixes)
	for _, resource := range service.Resources {
		if len(resource.Endpoints) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("// Mock%sAPI is a mock implementation of %sAPI\n", resource.Name, resource.Name))
		buf.WriteString(fmt.Sprintf("type Mock%sAPI struct {\n", resource.Name))

		// Generate function fields for each endpoint (no package prefixes)
		for _, endpoint := range resource.Endpoints {
			methodName := endpoint.Name

			if endpoint.HasResponseType() {
				responseType := endpoint.GetResponseType(resource.Name)
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request Request[any, %s, %s, %s]) (*%s, error)\n",
					methodName,
					getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name)),
					responseType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request Request[any, %s, %s, %s]) error\n",
					methodName,
					getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name))))
			}
		}

		buf.WriteString("}\n\n")

		// Generate mock methods for each endpoint (no package prefixes)
		for _, endpoint := range resource.Endpoints {
			err := generateInternalMockMethod(buf, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// generateInternalMockMethod generates an internal mock method for an endpoint.
func generateInternalMockMethod(buf *bytes.Buffer, resource specification.Resource, endpoint specification.Endpoint) error {
	methodName := endpoint.Name

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request Request[any, %s, %s, %s]) (*%s, error) {\n",
			resource.Name, methodName,
			getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name)),
			responseType))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil, nil\n")
	} else {
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request Request[any, %s, %s, %s]) error {\n",
			resource.Name, methodName,
			getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name))))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil\n")
	}

	buf.WriteString("}\n\n")

	return nil
}

// generateInternalUtilityTests generates internal tests for utility functions.
func generateInternalUtilityTests(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Utility function tests\n")
	buf.WriteString("// ============================================================================\n\n")

	// Test serveWithResponse (no package prefixes)
	buf.WriteString("func Test_serveWithResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that returns a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithResponse\n")
	buf.WriteString("\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\tassert.Contains(t, w.Body.String(), \"success\", \"Expected success message\")\n")
	buf.WriteString("}\n\n")

	// Test serveWithoutResponse
	buf.WriteString("func Test_serveWithoutResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that doesn't return a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request Request[any, struct{}, struct{}, struct{}]) error {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithoutResponse\n")
	buf.WriteString("\thandler := serveWithoutResponse(204, server, mockFunction)\n")
	buf.WriteString("\trouter.DELETE(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"DELETE\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 204, w.Code, \"Expected 204 status code\")\n")
	buf.WriteString("}\n\n")

	// Test handleRequest
	buf.WriteString("func Test_handleRequest(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	buf.WriteString("\tt.Run(\"successful request parsing\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n\n")

	buf.WriteString("\t\t// Create test request with JSON body\n")
	buf.WriteString("\t\ttestBody := `{\"name\": \"test\"}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test?limit=10&offset=0\", strings.NewReader(testBody))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n")
	buf.WriteString("\t\tc.Params = []gin.Param{{Key: \"id\", Value: \"123\"}}\n\n")

	buf.WriteString("\t\t// Create test server\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest\n")
	buf.WriteString("\t\trequestContext := getRequestContext(c, \"test-123\")\n")
	buf.WriteString("\t\trequest, apiError := handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.Nil(t, apiError, \"Expected no error from handleRequest\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-session\", request.Session, \"Session should be set\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-123\", request.Context().RequestID, \"RequestID should be set\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"session function error returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Create test server with session function that returns error\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn nil, fmt.Errorf(\"authentication failed\")\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with session error\n")
	buf.WriteString("\t\trequestContext := getRequestContext(c, \"test-456\")\n")
	buf.WriteString("\t\t_, err = handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.NotNil(t, err, \"Expected API error when session function fails\")\n")
	buf.WriteString("\t\tapiError, ok := err.(*Error)\n")
	buf.WriteString("\t\tassert.True(t, ok, \"Error should be of type *Error\")\n")
	buf.WriteString("\t\tassert.Equal(t, ErrorCodeUnauthorized, apiError.Code, \"Should return Unauthorized error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"authentication failed\", \"Error message should contain session error\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-456\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"invalid JSON body returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\t// Define test struct for body params\n")
	buf.WriteString("\t\ttype TestBodyParams struct {\n")
	buf.WriteString("\t\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\tinvalidJSON := `{\"name\": invalid json}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(invalidJSON))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Create test server\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with invalid JSON\n")
	buf.WriteString("\t\trequestContext := getRequestContext(c, \"test-789\")\n")
	buf.WriteString("\t\t_, err = handleRequest[any, struct{}, struct{}, TestBodyParams](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.NotNil(t, err, \"Expected API error when JSON is invalid\")\n")
	buf.WriteString("\t\tapiError, ok := err.(*Error)\n")
	buf.WriteString("\t\tassert.True(t, ok, \"Error should be of type *Error\")\n")
	buf.WriteString("\t\tassert.Equal(t, ErrorCodeBadRequest, apiError.Code, \"Should return BadRequest error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"cannot decode json body params\", \"Error message should mention JSON decoding\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-789\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"pre-hooks are executed in handleRequest\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\tvar hookExecuted bool\n")
	buf.WriteString("\t\tvar capturedContext RequestContext\n\n")

	buf.WriteString("\t\t// Create test server with pre-hook\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\thookExecuted = true\n")
	buf.WriteString("\t\t\t\t\tcapturedContext = requestContext\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with pre-hook\n")
	buf.WriteString("\t\trequestContext := getRequestContext(c, \"test-prehook\")\n")
	buf.WriteString("\t\t_, apiError := handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.Nil(t, apiError, \"Expected no error from handleRequest\")\n")
	buf.WriteString("\t\tassert.True(t, hookExecuted, \"Pre-hook should have been executed\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-prehook\", capturedContext.RequestID, \"Pre-hook should receive correct RequestID\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test\", capturedContext.Path, \"Pre-hook should receive correct Path\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"pre-hook error aborts handleRequest\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Create test server with pre-hook that returns error\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeForbidden,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\treturn fmt.Errorf(\"pre-hook validation failed\")\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test handleRequest with pre-hook error\n")
	buf.WriteString("\t\trequestContext := getRequestContext(c, \"test-prehook-error\")\n")
	buf.WriteString("\t\t_, err = handleRequest[any, struct{}, struct{}, struct{}](c, requestContext, server)\n")
	buf.WriteString("\t\tassert.NotNil(t, err, \"Expected API error when pre-hook fails\")\n")
	buf.WriteString("\t\tassert.Contains(t, err.Error(), \"pre-hook validation failed\", \"Error message should contain pre-hook error\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	// Test decodeBodyParams
	buf.WriteString("func Test_decodeBodyParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestBody struct {\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\tAge  int    `json:\"age\"`\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\ttestBody := `{\"name\": \"test\", \"age\": 25}`\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(testBody))\n")
	buf.WriteString("\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n\n")

	buf.WriteString("\t// Test decodeBodyParams\n")
	buf.WriteString("\tresult, err := decodeBodyParams[TestBody](req)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeBodyParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 25, result.Age, \"Age should be decoded as int\")\n")
	buf.WriteString("}\n\n")

	// Test decodePathParams
	buf.WriteString("func Test_decodePathParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestPathParams struct {\n")
	buf.WriteString("\t\tID   string `json:\"id\"`\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\tc.Params = []gin.Param{\n")
	buf.WriteString("\t\t{Key: \"id\", Value: \"123\"},\n")
	buf.WriteString("\t\t{Key: \"name\", Value: \"test\"},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Test decodePathParams\n")
	buf.WriteString("\tresult, err := decodePathParams[TestPathParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodePathParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"123\", result.ID, \"ID should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("}\n\n")

	// Test decodeQueryParams
	buf.WriteString("func Test_decodeQueryParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestQueryParams struct {\n")
	buf.WriteString("\t\tLimit  int  `form:\"limit\"`\n")
	buf.WriteString("\t\tOffset int  `form:\"offset\"`\n")
	buf.WriteString("\t\tActive bool `form:\"active\"`\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\treq, err := http.NewRequest(\"GET\", \"/test?limit=10&offset=0&active=true\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tc.Request = req\n\n")

	buf.WriteString("\t// Test decodeQueryParams\n")
	buf.WriteString("\tresult, err := decodeQueryParams[TestQueryParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeQueryParams\")\n")
	buf.WriteString("\tassert.Equal(t, 10, result.Limit, \"Limit should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 0, result.Offset, \"Offset should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, true, result.Active, \"Active should be decoded\")\n")
	buf.WriteString("}\n\n")

	// Test PreHooks functionality
	err := generateInternalPreHookTests(buf)
	if err != nil {
		return err
	}

	// Test SessionHooks functionality
	err = generateInternalSessionHookTests(buf)
	if err != nil {
		return err
	}

	return nil
}

// getInternalTypeReference returns type names without package prefixes for internal tests.
func getInternalTypeReference(typeName string) string {
	return typeName // No package prefix needed for internal tests
}

// getJSONKey converts a field name to its JSON key (camelCase).
func getJSONKey(fieldName string) string {
	return specification.CamelCase(fieldName)
}

// generateInternalPreHookTests generates internal tests for PreHook functionality.
func generateInternalPreHookTests(buf *bytes.Buffer) error {
	buf.WriteString("func Test_PreHooks(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	// Test successful pre-hook execution
	buf.WriteString("\tt.Run(\"successful pre-hook execution\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar capturedContext RequestContext\n\n")

	buf.WriteString("\t\t// Mock function that returns a response\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with pre-hook\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\tcapturedContext = requestContext\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test/path\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test/path\", nil)\n")
	buf.WriteString("\t\treq.RemoteAddr = \"127.0.0.1:12345\"\n")
	buf.WriteString("\t\treq.Header.Set(\"User-Agent\", \"test-agent\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.NotEmpty(t, capturedContext.RequestID, \"RequestID should be set\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test/path\", capturedContext.Path, \"Path should match\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test/path\", capturedContext.Route, \"Route should match\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-agent\", capturedContext.UserAgent, \"UserAgent should match\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"POST\", capturedContext.HTTPMethod, \"HTTPMethod should match\")\n")
	buf.WriteString("\t\tassert.NotEmpty(t, capturedContext.IPAddress, \"IPAddress should be set\")\n")
	buf.WriteString("\t})\n\n")

	// Test pre-hook aborting request
	buf.WriteString("\tt.Run(\"pre-hook aborts request\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n\n")

	buf.WriteString("\t\t// Mock function that should not be called\n")
	buf.WriteString("\t\tvar functionCalled bool\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\tfunctionCalled = true\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with pre-hook that returns error\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeForbidden,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\treturn fmt.Errorf(\"not allowed to request server atm\")\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 403, w.Code, \"Expected 403 status code\")\n")
	buf.WriteString("\t\tassert.False(t, functionCalled, \"Endpoint function should not be called\")\n")
	buf.WriteString("\t\tassert.Contains(t, w.Body.String(), \"not allowed to request server atm\", \"Error message should be in response\")\n")
	buf.WriteString("\t})\n\n")

	// Test multiple pre-hooks
	buf.WriteString("\tt.Run(\"multiple pre-hooks execute in order\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar executionOrder []string\n\n")

	buf.WriteString("\t\t// Mock function\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with multiple pre-hooks\n")
	buf.WriteString("\t\tserver := Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"hook1\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"hook2\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"hook3\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response and execution order\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.Equal(t, []string{\"hook1\", \"hook2\", \"hook3\"}, executionOrder, \"Hooks should execute in order\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateInternalSessionHookTests generates internal tests for SessionHook functionality.
func generateInternalSessionHookTests(buf *bytes.Buffer) error {
	buf.WriteString("func Test_SessionHooks(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	// Test successful session hook execution
	buf.WriteString("\tt.Run(\"successful session-hook execution\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar capturedContext RequestContext\n")
	buf.WriteString("\t\tvar capturedSession string\n\n")

	buf.WriteString("\t\t// Mock function that returns a response\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with session hook\n")
	buf.WriteString("\t\tserver := Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"user-session-456\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\tcapturedContext = requestContext\n")
	buf.WriteString("\t\t\t\t\tcapturedSession = session\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test/session/path\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test/session/path\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\treq.Header.Set(\"User-Agent\", \"Test-Agent\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"user-session-456\", capturedSession, \"Session hook should receive the authenticated session\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test/session/path\", capturedContext.Path, \"Request context should have correct path\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"Test-Agent\", capturedContext.UserAgent, \"Request context should have correct user agent\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"POST\", capturedContext.HTTPMethod, \"Request context should have correct HTTP method\")\n")
	buf.WriteString("\t})\n\n")

	// Test session hook error
	buf.WriteString("\tt.Run(\"session-hook error aborts request\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar functionCalled bool\n\n")

	buf.WriteString("\t\t// Mock function that should not be called\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\tfunctionCalled = true\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with session hook that returns error\n")
	buf.WriteString("\t\tserver := Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"user-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeForbidden,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\treturn fmt.Errorf(\"user does not have required permissions\")\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 403, w.Code, \"Expected 403 status code\")\n")
	buf.WriteString("\t\tassert.False(t, functionCalled, \"Endpoint function should not be called\")\n")
	buf.WriteString("\t\tassert.Contains(t, w.Body.String(), \"user does not have required permissions\", \"Error message should be in response\")\n")
	buf.WriteString("\t})\n\n")

	// Test multiple session hooks
	buf.WriteString("\tt.Run(\"multiple session-hooks execute in order\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar executionOrder []string\n\n")

	buf.WriteString("\t\t// Mock function\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with multiple session hooks\n")
	buf.WriteString("\t\tserver := Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"logging-hook\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"rate-limit-hook\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"authz-hook\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response and execution order\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.Equal(t, []string{\"logging-hook\", \"rate-limit-hook\", \"authz-hook\"}, executionOrder, \"Session hooks should execute in order\")\n")
	buf.WriteString("\t})\n\n")

	// Test session hooks run after authentication
	buf.WriteString("\tt.Run(\"session-hooks run after authentication\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar sessionHookCalled bool\n\n")

	buf.WriteString("\t\t// Mock function\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server where authentication fails\n")
	buf.WriteString("\t\tserver := Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"\", &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:    ErrorCodeUnauthorized,\n")
	buf.WriteString("\t\t\t\t\tMessage: types.NewString(\"authentication failed\"),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext RequestContext, err error) *Error {\n")
	buf.WriteString("\t\t\t\tif apiErr, ok := err.(*Error); ok {\n")
	buf.WriteString("\t\t\t\t\treturn apiErr\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\tsessionHookCalled = true\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 401, w.Code, \"Expected 401 status code\")\n")
	buf.WriteString("\t\tassert.False(t, sessionHookCalled, \"Session hook should not be called when authentication fails\")\n")
	buf.WriteString("\t\tassert.Contains(t, w.Body.String(), \"authentication failed\", \"Error message should be in response\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generatePreHookTests generates tests for PreHook functionality.
func generatePreHookTests(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_PreHooks(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	// Test successful pre-hook execution
	buf.WriteString("\tt.Run(\"successful pre-hook execution\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar capturedContext " + apiPackageName + ".RequestContext\n\n")

	buf.WriteString("\t\t// Mock function that returns a response\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with pre-hook\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []" + apiPackageName + ".PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\tcapturedContext = requestContext\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test/path\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test/path\", nil)\n")
	buf.WriteString("\t\treq.RemoteAddr = \"127.0.0.1:12345\"\n")
	buf.WriteString("\t\treq.Header.Set(\"User-Agent\", \"test-agent\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.NotEmpty(t, capturedContext.RequestID, \"RequestID should be set\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test/path\", capturedContext.Path, \"Path should match\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test/path\", capturedContext.Route, \"Route should match\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-agent\", capturedContext.UserAgent, \"UserAgent should match\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"POST\", capturedContext.HTTPMethod, \"HTTPMethod should match\")\n")
	buf.WriteString("\t\tassert.NotEmpty(t, capturedContext.IPAddress, \"IPAddress should be set\")\n")
	buf.WriteString("\t})\n\n")

	// Test pre-hook aborting request
	buf.WriteString("\tt.Run(\"pre-hook aborts request\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n\n")

	buf.WriteString("\t\t// Mock function that should not be called\n")
	buf.WriteString("\t\tvar functionCalled bool\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\tfunctionCalled = true\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with pre-hook that returns error\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeForbidden,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []" + apiPackageName + ".PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\treturn fmt.Errorf(\"not allowed to request server atm\")\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 403, w.Code, \"Expected 403 status code\")\n")
	buf.WriteString("\t\tassert.False(t, functionCalled, \"Endpoint function should not be called\")\n")
	buf.WriteString("\t\tassert.Contains(t, w.Body.String(), \"not allowed to request server atm\", \"Error message should be in response\")\n")
	buf.WriteString("\t})\n\n")

	// Test multiple pre-hooks
	buf.WriteString("\tt.Run(\"multiple pre-hooks execute in order\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar executionOrder []string\n\n")

	buf.WriteString("\t\t// Mock function\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with multiple pre-hooks\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tPreHooks: []" + apiPackageName + ".PreHook{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"hook1\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"hook2\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"hook3\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response and execution order\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.Equal(t, []string{\"hook1\", \"hook2\", \"hook3\"}, executionOrder, \"Hooks should execute in order\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateSessionHookTests generates tests for SessionHook functionality.
func generateSessionHookTests(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_SessionHooks(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	// Test successful session hook execution
	buf.WriteString("\tt.Run(\"successful session-hook execution\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar capturedContext " + apiPackageName + ".RequestContext\n")
	buf.WriteString("\t\tvar capturedSession string\n\n")

	buf.WriteString("\t\t// Mock function that returns a response\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with session hook\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"user-session-456\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []" + apiPackageName + ".SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\tcapturedContext = requestContext\n")
	buf.WriteString("\t\t\t\t\tcapturedSession = session\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test/session/path\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test/session/path\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\treq.Header.Set(\"User-Agent\", \"Test-Agent\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"user-session-456\", capturedSession, \"Session hook should receive the authenticated session\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"/test/session/path\", capturedContext.Path, \"Request context should have correct path\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"Test-Agent\", capturedContext.UserAgent, \"Request context should have correct user agent\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"POST\", capturedContext.HTTPMethod, \"Request context should have correct HTTP method\")\n")
	buf.WriteString("\t})\n\n")

	// Test session hook error
	buf.WriteString("\tt.Run(\"session-hook error aborts request\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar functionCalled bool\n\n")

	buf.WriteString("\t\t// Mock function that should not be called\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\tfunctionCalled = true\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with session hook that returns error\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"user-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeForbidden,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []" + apiPackageName + ".SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\treturn fmt.Errorf(\"user does not have required permissions\")\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 403, w.Code, \"Expected 403 status code\")\n")
	buf.WriteString("\t\tassert.False(t, functionCalled, \"Endpoint function should not be called\")\n")
	buf.WriteString("\t\tassert.Contains(t, w.Body.String(), \"user does not have required permissions\", \"Error message should be in response\")\n")
	buf.WriteString("\t})\n\n")

	// Test multiple session hooks
	buf.WriteString("\tt.Run(\"multiple session-hooks execute in order\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar executionOrder []string\n\n")

	buf.WriteString("\t\t// Mock function\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server configuration with multiple session hooks\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []" + apiPackageName + ".SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"logging-hook\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"rate-limit-hook\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\texecutionOrder = append(executionOrder, \"authz-hook\")\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response and execution order\n")
	buf.WriteString("\t\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\t\tassert.Equal(t, []string{\"logging-hook\", \"rate-limit-hook\", \"authz-hook\"}, executionOrder, \"Session hooks should execute in order\")\n")
	buf.WriteString("\t})\n\n")

	// Test session hooks run after authentication
	buf.WriteString("\tt.Run(\"session-hooks run after authentication\", func(t *testing.T) {\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString("\t\tvar sessionHookCalled bool\n\n")

	buf.WriteString("\t\t// Mock function\n")
	buf.WriteString("\t\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[string, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create server where authentication fails\n")
	buf.WriteString("\t\tserver := " + apiPackageName + ".Server[string]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header) (string, error) {\n")
	buf.WriteString("\t\t\t\treturn \"\", &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:    " + apiPackageName + ".ErrorCodeUnauthorized,\n")
	buf.WriteString("\t\t\t\t\tMessage: types.NewString(\"authentication failed\"),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tErrorHook: func(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, err error) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\t\tif apiErr, ok := err.(*" + apiPackageName + ".Error); ok {\n")
	buf.WriteString("\t\t\t\t\treturn apiErr\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestContext.RequestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tSessionHooks: []" + apiPackageName + ".SessionHook[string]{\n")
	buf.WriteString("\t\t\t\tfunc(ctx context.Context, requestContext " + apiPackageName + ".RequestContext, session string) error {\n")
	buf.WriteString("\t\t\t\t\tsessionHookCalled = true\n")
	buf.WriteString("\t\t\t\t\treturn nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Create handler\n")
	buf.WriteString("\t\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\t\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t\t// Create test request\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tw := httptest.NewRecorder()\n")
	buf.WriteString("\t\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t\t// Assert response\n")
	buf.WriteString("\t\tassert.Equal(t, 401, w.Code, \"Expected 401 status code\")\n")
	buf.WriteString("\t\tassert.False(t, sessionHookCalled, \"Session hook should not be called when authentication fails\")\n")
	buf.WriteString("\t\tassert.Contains(t, w.Body.String(), \"authentication failed\", \"Error message should be in response\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}
