package testgen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/aarondl/strmangle"
	"github.com/meitner-se/publicapis-gen/specification"
)

const (
	disclaimerComment = "// Code generated by publicapis-gen testgen. DO NOT EDIT.\n// This file is automatically generated from the API specification.\n// Any changes made to this file will be overwritten on the next generation.\n\n"
)

// GenerateTests generates HTTP API tests from a service specification.
func GenerateTests(buf *bytes.Buffer, service *specification.Service, packageName string, apiPackageName string, apiPackageImport string) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports
	err := generateImports(buf, apiPackageName, apiPackageImport)
	if err != nil {
		return err
	}

	// Generate test constants
	err = generateTestConstants(buf, service)
	if err != nil {
		return err
	}

	// Generate tests for each resource endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			err = generateEndpointTest(buf, service, resource, endpoint, apiPackageName)
			if err != nil {
				return err
			}
		}
	}

	// Generate helper functions
	err = generateHelperFunctions(buf, service, apiPackageName)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

// generateImports generates the import section for the test file.
func generateImports(buf *bytes.Buffer, apiPackageName string, apiPackageImport string) error {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString("\t\"testing\"\n\n")
	buf.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString("\t\"github.com/meitner-se/go-types\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/assert\"\n")
	if apiPackageImport != "" {
		if apiPackageName != "" && apiPackageName != "api" {
			buf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", apiPackageName, apiPackageImport))
		} else {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", apiPackageImport))
		}
	}
	buf.WriteString(")\n\n")

	return nil
}

// generateTestConstants generates constants used across tests.
func generateTestConstants(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// Test constants\n")
	buf.WriteString("const (\n")
	buf.WriteString("\ttestRequestID = \"test-request-id-123\"\n")
	buf.WriteString("\ttestSessionUserID = \"test-session-user-id\"\n")
	buf.WriteString("\ttestTimeout = \"30s\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateEndpointTest generates a test function for a specific endpoint.
func generateEndpointTest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	serviceName := strmangle.TitleCase(service.Name)
	testName := fmt.Sprintf("Test%s%s", resource.Name, endpoint.Name)

	buf.WriteString(fmt.Sprintf("// %s tests the %s endpoint for %s\n", testName, endpoint.Name, resource.Name))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testName))
	buf.WriteString("\tt.Run(\"Request\", func(t *testing.T) {\n")

	// Generate test setup (without parameters)
	err := generateTestSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate mock setup
	err = generateMockSetup(buf, service, resource, endpoint, apiPackageName)
	if err != nil {
		return err
	}

	// Generate server setup
	err = generateServerSetup(buf, serviceName, service, resource, endpoint, apiPackageName)
	if err != nil {
		return err
	}

	// Generate HTTP request (with parameters defined inline)
	err = generateHTTPRequest(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate assertions
	err = generateAssertions(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateTestSetup generates the test setup section.
func generateTestSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Arrange\n")
	buf.WriteString("\t\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\t\tctx := context.Background()\n\n")

	return nil
}

// generateTestParameterValue generates a test value for a parameter.
func generateTestParameterValue(buf *bytes.Buffer, param specification.Field, paramType string) error {
	varName := fmt.Sprintf("test%s%s", strmangle.TitleCase(paramType), strmangle.TitleCase(param.Name))

	switch param.Type {
	case "UUID":
		buf.WriteString(fmt.Sprintf("\t\t%s := uuid.New().String()\n", varName))
	case "String":
		defaultValue := "test-value"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	case "Int":
		defaultValue := "123"
		if param.Example != "" {
			defaultValue = param.Example
		}
		// Use float64 for consistency with JSON unmarshaling
		buf.WriteString(fmt.Sprintf("\t\t%s := float64(%s)\n", varName, defaultValue))
	case "Bool":
		defaultValue := "true"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := %s\n", varName, defaultValue))
	case "Date":
		defaultValue := "2024-01-15"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	case "Timestamp":
		defaultValue := "2024-01-15T10:30:00Z"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	default:
		// For custom types, generate a basic string value
		buf.WriteString(fmt.Sprintf("\t\t%s := \"test-%s-value\"\n", varName, strings.ToLower(param.Name)))
	}

	return nil
}

// generateTestBody generates test data for request body.
func generateTestBody(buf *bytes.Buffer, bodyParams []specification.Field, service *specification.Service) error {
	buf.WriteString("\t\ttestBody := map[string]interface{}{\n")

	for _, param := range bodyParams {
		jsonKey := getJSONKey(param.Name)

		if param.IsArray() {
			// Handle array types
			switch param.Type {
			case "UUID":
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{uuid.New().String()},\n", jsonKey))
			case "String":
				defaultValue := "test-value"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			case "Int":
				defaultValue := "123"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{float64(%s)},\n", jsonKey, defaultValue))
			case "Bool":
				defaultValue := "true"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{%s},\n", jsonKey, defaultValue))
			case "Date":
				defaultValue := "2024-01-15"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			case "Timestamp":
				defaultValue := "2024-01-15T10:30:00Z"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			default:
				// For custom object arrays, create an array with one test object
				if service.IsObject(param.Type) {
					visited := make(map[string]bool)
					objectFields := getObjectTestDataWithVisited(param.Type, service, visited)
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{map[string]interface{}{%s}},\n", jsonKey, objectFields))
				} else {
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"test-%s-value\"},\n", jsonKey, strings.ToLower(param.Name)))
				}
			}
		} else {
			// Handle single value types
			switch param.Type {
			case "UUID":
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": uuid.New().String(),\n", jsonKey))
			case "String":
				defaultValue := "test-value"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			case "Int":
				defaultValue := "123"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": float64(%s),\n", jsonKey, defaultValue))
			case "Bool":
				defaultValue := "true"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": %s,\n", jsonKey, defaultValue))
			case "Date":
				defaultValue := "2024-01-15"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			case "Timestamp":
				defaultValue := "2024-01-15T10:30:00Z"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			default:
				// For custom object types, create a nested object
				if service.IsObject(param.Type) {
					visited := make(map[string]bool)
					objectFields := getObjectTestDataWithVisited(param.Type, service, visited)
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": map[string]interface{}{%s},\n", jsonKey, objectFields))
				} else {
					// For enums or unknown types, use string
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"test-%s-value\",\n", jsonKey, strings.ToLower(param.Name)))
				}
			}
		}
	}

	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\ttestBodyBytes, err := json.Marshal(testBody)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal test body\")\n")

	return nil
}

// generateMockSetup generates mock service setup that captures the request for parameter validation.
func generateMockSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	buf.WriteString("\t\t// Mock service setup\n")
	buf.WriteString(fmt.Sprintf("\t\tvar capturedRequest %s.Request[any, %s, %s, %s]\n",
		apiPackageName,
		getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
		getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
		getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))

	// The mock configuration is now handled in generateServerSetup
	// This function just declares the captured request variable

	return nil
}

// generateServerSetup generates HTTP server setup.
func generateServerSetup(buf *bytes.Buffer, serviceName string, service *specification.Service, currentResource specification.Resource, currentEndpoint specification.Endpoint, apiPackageName string) error {
	buf.WriteString("\t\t// Server setup\n")
	buf.WriteString("\t\trouter := gin.New()\n")

	// Create and configure only the mock for the resource being tested
	buf.WriteString(fmt.Sprintf("\t\tmock%sAPI := &Mock%sAPI{}\n", currentResource.Name, currentResource.Name))

	methodName := currentEndpoint.Name
	if currentEndpoint.HasResponseType() {
		responseType := currentEndpoint.GetResponseType(currentResource.Name)
		buf.WriteString(fmt.Sprintf("\t\texpected%s := &%s.%s{\n", responseType, apiPackageName, responseType))
		buf.WriteString("\t\t\t// Add expected response fields here based on your needs\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error) {\n",
			currentResource.Name, methodName, apiPackageName,
			getAPITypeReference(currentEndpoint.GetPathParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name), apiPackageName),
			apiPackageName, responseType))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString(fmt.Sprintf("\t\t\treturn expected%s, nil\n", responseType))
		buf.WriteString("\t\t}\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s.Request[any, %s, %s, %s]) error {\n",
			currentResource.Name, methodName, apiPackageName,
			getAPITypeReference(currentEndpoint.GetPathParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name), apiPackageName)))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString("\t\t\treturn nil\n")
		buf.WriteString("\t\t}\n")
	}
	buf.WriteString("\n")

	buf.WriteString(fmt.Sprintf("\t\t%s.Register%sAPI(router, &%s.%sAPI[any]{\n", apiPackageName, serviceName, apiPackageName, serviceName))
	buf.WriteString(fmt.Sprintf("\t\t\tServer: %s.Server[any]{\n", apiPackageName))
	buf.WriteString("\t\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\t\t\treturn testSessionUserID, nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString(fmt.Sprintf("\t\t\t\tConvertErrorFunc: func(err error, requestID string) *%s.Error {\n", apiPackageName))
	buf.WriteString(fmt.Sprintf("\t\t\t\t\treturn &%s.Error{\n", apiPackageName))
	buf.WriteString(fmt.Sprintf("\t\t\t\t\t\tCode:      %s.ErrorCodeInternal,\n", apiPackageName))
	buf.WriteString("\t\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t\t\t}\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")

	// Add all resource mocks to the API struct
	for _, resource := range service.Resources {
		if len(resource.Endpoints) > 0 {
			if resource.Name == currentResource.Name {
				// Use the configured mock for the resource being tested
				buf.WriteString(fmt.Sprintf("\t\t\t%s: mock%sAPI,\n", resource.Name, resource.Name))
			} else {
				// Create inline mocks for other resources to prevent panics
				buf.WriteString(fmt.Sprintf("\t\t\t%s: &Mock%sAPI{},\n", resource.Name, resource.Name))
			}
		}
	}

	buf.WriteString("\t\t})\n")
	buf.WriteString("\t\tserver := httptest.NewServer(router)\n")
	buf.WriteString("\t\tdefer server.Close()\n\n")

	return nil
}

// generateHTTPRequest generates the HTTP request execution.
func generateHTTPRequest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Act - Execute HTTP request\n")

	// Build URL
	path := endpoint.GetFullPath(resource.Name)
	buf.WriteString(fmt.Sprintf("\t\trequestURL := server.URL + \"/%s/%s%s\"\n", service.PathName(), service.Version, path))

	// Generate and use path parameters
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Path parameters\n")
		for _, param := range endpoint.Request.PathParams {
			err := generateTestParameterValue(buf, param, "path")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")

		// Replace path parameters in URL
		for _, param := range endpoint.Request.PathParams {
			paramName := fmt.Sprintf("{%s}", strings.ToLower(param.Name))
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			buf.WriteString(fmt.Sprintf("\t\trequestURL = strings.ReplaceAll(requestURL, \"%s\", %s)\n", paramName, varName))
		}
		buf.WriteString("\n")
	}

	// Generate and use query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Query parameters\n")
		for _, param := range endpoint.Request.QueryParams {
			err := generateTestParameterValue(buf, param, "query")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")

		buf.WriteString("\t\t// Add query parameters to URL\n")
		buf.WriteString("\t\tquery := url.Values{}\n")
		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tquery.Add(\"%s\", fmt.Sprintf(\"%%v\", %s))\n", jsonKey, varName))
		}
		buf.WriteString("\t\tif len(query) > 0 {\n")
		buf.WriteString("\t\t\trequestURL += \"?\" + query.Encode()\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\n")
	}

	// Generate and use body parameters
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Body parameters\n")
		err := generateTestBody(buf, endpoint.Request.BodyParams, service)
		if err != nil {
			return err
		}
		buf.WriteString("\n")
	}

	// Create request
	method := strings.ToUpper(endpoint.Method)
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, bytes.NewBuffer(testBodyBytes))\n", method))
	} else {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, nil)\n", method))
	}

	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create HTTP request\")\n")

	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	}

	// Execute request
	buf.WriteString("\t\tresp, err := http.DefaultClient.Do(req)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to execute HTTP request\")\n")
	buf.WriteString("\t\tdefer resp.Body.Close()\n\n")

	return nil
}

// generateAssertions generates test assertions.
func generateAssertions(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Assert\n")
	buf.WriteString("\t\t// Read response body for debugging and verification\n")
	buf.WriteString("\t\tresponseBodyBytes, err := io.ReadAll(resp.Body)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to read response body\")\n\n")

	buf.WriteString("\t\t// Check status code and print response body if unexpected\n")
	buf.WriteString("\t\tif resp.StatusCode != " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + " {\n")
	buf.WriteString("\t\t\tt.Errorf(\"Expected HTTP status %d, got %d. Response body: %s\", " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + ", resp.StatusCode, string(responseBodyBytes))\n")
	buf.WriteString("\t\t\treturn\n")
	buf.WriteString("\t\t}\n\n")

	if endpoint.HasResponseType() {
		buf.WriteString("\t\t// Verify response body\n")
		buf.WriteString("\t\tvar responseBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(responseBodyBytes, &responseBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to decode response body\")\n")
		buf.WriteString("\t\tassert.NotNil(t, responseBody, \"Response body should not be nil\")\n")
	}

	// Verify the service method was called with the request
	buf.WriteString("\t\t// Verify service method was called (indicating HTTP request was processed)\n")
	buf.WriteString("\t\tassert.NotNil(t, capturedRequest, \"Service method should have been called with a request\")\n\n")

	// Assert path parameters by converting to JSON for easy comparison
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Verify path parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedPathBytes, err := json.Marshal(capturedRequest.PathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured path params\")\n")
		buf.WriteString("\t\tvar capturedPathParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedPathBytes, &capturedPathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured path params\")\n\n")

		for _, param := range endpoint.Request.PathParams {
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedPathParams[\"%s\"], \"Path parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert query parameters by converting to JSON for easy comparison
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Verify query parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedQueryBytes, err := json.Marshal(capturedRequest.QueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured query params\")\n")
		buf.WriteString("\t\tvar capturedQueryParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedQueryBytes, &capturedQueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured query params\")\n\n")

		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedQueryParams[\"%s\"], \"Query parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert body parameters by converting captured request body to JSON for easy comparison
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Verify body parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedBodyBytes, err := json.Marshal(capturedRequest.BodyParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured body params\")\n")
		buf.WriteString("\t\tvar capturedRequestBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedBodyBytes, &capturedRequestBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured body params\")\n\n")

		for _, param := range endpoint.Request.BodyParams {
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequestBody[\"%s\"], \"Body parameter %s should match\")\n",
				jsonKey, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateHelperFunctions generates helper functions and mock interfaces.
func generateHelperFunctions(buf *bytes.Buffer, service *specification.Service, apiPackageName string) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Mock interfaces and helper functions\n")
	buf.WriteString("// ============================================================================\n\n")

	// Generate mock interfaces for each resource
	for _, resource := range service.Resources {
		if len(resource.Endpoints) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("// Mock%sAPI is a mock implementation of %sAPI\n", resource.Name, resource.Name))
		buf.WriteString(fmt.Sprintf("type Mock%sAPI struct {\n", resource.Name))

		// Generate function fields for each endpoint
		for _, endpoint := range resource.Endpoints {
			methodName := endpoint.Name

			if endpoint.HasResponseType() {
				responseType := endpoint.GetResponseType(resource.Name)
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error)\n",
					methodName, apiPackageName,
					getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName),
					apiPackageName, responseType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s.Request[any, %s, %s, %s]) error\n",
					methodName, apiPackageName,
					getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))
			}
		}

		buf.WriteString("}\n\n")

		// Generate mock methods for each endpoint
		for _, endpoint := range resource.Endpoints {
			err := generateMockMethod(buf, resource, endpoint, apiPackageName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// generateMockMethod generates a mock method for an endpoint.
func generateMockMethod(buf *bytes.Buffer, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	methodName := endpoint.Name

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error) {\n",
			resource.Name, methodName, apiPackageName,
			getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName),
			apiPackageName, responseType))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString(fmt.Sprintf("\treturn nil, nil\n"))
	} else {
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s.Request[any, %s, %s, %s]) error {\n",
			resource.Name, methodName, apiPackageName,
			getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil\n")
	}

	buf.WriteString("}\n\n")

	return nil
}

// getAPITypeReference adds the API package prefix to type names, except for built-in types like struct{}.
func getAPITypeReference(typeName string, apiPackageName string) string {
	if typeName == "struct{}" {
		return "struct{}"
	}
	return apiPackageName + "." + typeName
}

// getObjectTestData generates test data for a custom object type.
func getObjectTestData(objectType string, service *specification.Service) string {
	visited := make(map[string]bool)
	return getObjectTestDataWithVisited(objectType, service, visited)
}

// getObjectTestDataWithVisited generates test data for a custom object type with recursion protection.
func getObjectTestDataWithVisited(objectType string, service *specification.Service, visited map[string]bool) string {
	// Check for circular references
	if visited[objectType] {
		return "" // Avoid infinite recursion - return empty string for truly empty object
	}
	visited[objectType] = true

	// Find the object definition
	for _, obj := range service.Objects {
		if obj.Name == objectType {
			var fields []string
			for _, field := range obj.Fields {
				jsonKey := getJSONKey(field.Name)

				// Skip nullable fields to avoid nil value issues in test data
				if field.IsNullable() {
					continue
				}

				if field.IsArray() {
					// Handle array fields in objects
					switch field.Type {
					case "UUID":
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{uuid.New().String()}", jsonKey))
					case "String":
						defaultValue := "test-value"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					case "Int":
						defaultValue := "123"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{float64(%s)}", jsonKey, defaultValue))
					case "Bool":
						defaultValue := "true"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{%s}", jsonKey, defaultValue))
					case "Date":
						defaultValue := "2024-01-15"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					case "Timestamp":
						defaultValue := "2024-01-15T10:30:00Z"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					default:
						// For custom object arrays, create an array with one test object
						if service.IsObject(field.Type) {
							nestedObjectFields := getObjectTestDataWithVisited(field.Type, service, visited)
							if nestedObjectFields != "" {
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{map[string]interface{}{%s}}", jsonKey, nestedObjectFields))
							} else {
								// For circular references, create empty array
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{}", jsonKey))
							}
						} else {
							fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"test-%s-value\"}", jsonKey, strings.ToLower(field.Name)))
						}
					}
				} else {
					// Handle single value fields in objects
					switch field.Type {
					case "UUID":
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": uuid.New().String()", jsonKey))
					case "String":
						defaultValue := "test-value"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					case "Int":
						defaultValue := "123"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": float64(%s)", jsonKey, defaultValue))
					case "Bool":
						defaultValue := "true"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": %s", jsonKey, defaultValue))
					case "Date":
						defaultValue := "2024-01-15"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					case "Timestamp":
						defaultValue := "2024-01-15T10:30:00Z"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					default:
						// For nested objects, create proper object structure recursively
						if service.IsObject(field.Type) {
							nestedObjectFields := getObjectTestDataWithVisited(field.Type, service, visited)
							if nestedObjectFields != "" {
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": map[string]interface{}{%s}", jsonKey, nestedObjectFields))
							}
							// Skip circular references entirely - don't add field at all
						} else {
							// For enums, use string for simplicity
							fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"test-%s-value\"", jsonKey, strings.ToLower(field.Name)))
						}
					}
				}
			}

			if len(fields) > 0 {
				return strings.Join(fields, ",") + ",\n\t\t\t"
			}
			return ""
		}
	}

	// If object not found, return empty
	return ""
}

// getJSONKey converts a field name to its JSON key (camelCase).
func getJSONKey(fieldName string) string {
	return specification.CamelCase(fieldName)
}
