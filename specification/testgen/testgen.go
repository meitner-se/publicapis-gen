package testgen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/aarondl/strmangle"
	"github.com/meitner-se/publicapis-gen/specification"
)

const (
	disclaimerComment = "// Code generated by publicapis-gen testgen. DO NOT EDIT.\n// This file is automatically generated from the API specification.\n// Any changes made to this file will be overwritten on the next generation.\n\n"
)

// GenerateTests generates HTTP API tests from a service specification.
func GenerateTests(buf *bytes.Buffer, service *specification.Service, packageName string) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports
	err := generateImports(buf)
	if err != nil {
		return err
	}

	// Generate test constants
	err = generateTestConstants(buf, service)
	if err != nil {
		return err
	}

	// Generate enums (needed for type definitions)
	err = generateEnums(buf, service.Enums)
	if err != nil {
		return err
	}

	// Generate objects (needed for type definitions)
	err = generateObjects(buf, service)
	if err != nil {
		return err
	}

	// Generate request types (needed for type-safe testing)
	err = generateRequestTypes(buf, service)
	if err != nil {
		return err
	}

	// Generate tests for each resource endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			err = generateEndpointTest(buf, service, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	// Generate helper functions
	err = generateHelperFunctions(buf, service)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

// generateImports generates the import section for the test file.
func generateImports(buf *bytes.Buffer) error {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString("\t\"testing\"\n\n")
	buf.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString("\t\"github.com/meitner-se/go-types\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/assert\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateTestConstants generates constants used across tests.
func generateTestConstants(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// Test constants\n")
	buf.WriteString("const (\n")
	buf.WriteString("\ttestRequestID = \"test-request-id-123\"\n")
	buf.WriteString("\ttestSessionUserID = \"test-session-user-id\"\n")
	buf.WriteString("\ttestTimeout = \"30s\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateEnums generates enum types needed for testing.
func generateEnums(buf *bytes.Buffer, enums []specification.Enum) error {
	for _, enumStruct := range enums {
		buf.WriteString(fmt.Sprintf("type %s types.String\n\n", enumStruct.Name))

		buf.WriteString("var (\n")
		for _, value := range enumStruct.Values {
			buf.WriteString(fmt.Sprintf("\t%s%s = %s(types.NewString(\"%s\")) // %s\n", enumStruct.Name, value.Name, enumStruct.Name, value.Name, value.Description))
		}
		buf.WriteString(")\n\n")
	}

	return nil
}

// generateObjects generates object types needed for testing.
func generateObjects(buf *bytes.Buffer, service *specification.Service) error {
	for _, object := range service.Objects {
		buf.WriteString(fmt.Sprintf("// %s\n", object.GetComment()))
		buf.WriteString(fmt.Sprintf("type %s struct {\n", object.Name))

		for _, field := range object.Fields {
			buf.WriteString(fmt.Sprintf("%s\n", field.GetComment("\t")))
			buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n\n", field.Name, getGoTypeForField(field, service), field.TagJSON()))
		}

		buf.WriteString("}\n\n")

		// Add Error methods if this is an Error object
		if object.Name == "Error" {
			buf.WriteString("func (e *Error) Error() string {\n")
			buf.WriteString("\treturn e.Message.String()\n")
			buf.WriteString("}\n\n")

			buf.WriteString("func (e *Error) HTTPStatusCode() int {\n")
			buf.WriteString("\tswitch e.Code {\n")
			buf.WriteString("\tcase ErrorCodeBadRequest:\n")
			buf.WriteString("\t\treturn http.StatusBadRequest\n")
			buf.WriteString("\tcase ErrorCodeUnauthorized:\n")
			buf.WriteString("\t\treturn http.StatusUnauthorized\n")
			buf.WriteString("\tcase ErrorCodeForbidden:\n")
			buf.WriteString("\t\treturn http.StatusForbidden\n")
			buf.WriteString("\tcase ErrorCodeNotFound:\n")
			buf.WriteString("\t\treturn http.StatusNotFound\n")
			buf.WriteString("\tcase ErrorCodeConflict:\n")
			buf.WriteString("\t\treturn http.StatusConflict\n")
			buf.WriteString("\tcase ErrorCodeUnprocessableEntity:\n")
			buf.WriteString("\t\treturn http.StatusUnprocessableEntity\n")
			buf.WriteString("\tcase ErrorCodeRateLimited:\n")
			buf.WriteString("\t\treturn http.StatusTooManyRequests\n")
			buf.WriteString("\tcase ErrorCodeInternal:\n")
			buf.WriteString("\t\treturn http.StatusInternalServerError\n")
			buf.WriteString("\tdefault:\n")
			buf.WriteString("\t\treturn http.StatusInternalServerError\n")
			buf.WriteString("\t}\n")
			buf.WriteString("}\n\n")
		}
	}

	return nil
}

// generateRequestTypes generates the request types needed for testing.
func generateRequestTypes(buf *bytes.Buffer, service *specification.Service) error {
	// Generate the generic Request type
	buf.WriteString("type Request[sessionType, pathParamsType, queryParamsType, bodyParamsType any] struct {\n")
	buf.WriteString("\trequestID string `json:\"-\"` // Unexported field since it shouldn't be changed\n")
	buf.WriteString("\tSession sessionType `json:\"-\"`\n")
	buf.WriteString("\tPathParams pathParamsType `json:\"-\"`\n")
	buf.WriteString("\tQueryParams queryParamsType `json:\"-\"`\n")
	buf.WriteString("\tBodyParams bodyParamsType `json:\"-\"`\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func (r Request[sessionType, pathParamsType, queryParamsType, bodyParamsType]) RequestID() string {\n")
	buf.WriteString("\treturn r.requestID\n")
	buf.WriteString("}\n\n")

	// Generate parameter types for each endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			if len(endpoint.Request.PathParams) > 0 {
				buf.WriteString(fmt.Sprintf("type %s struct {\n", endpoint.GetPathParamsType(resource.Name)))
				for _, field := range endpoint.Request.PathParams {
					buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", field.Name, getGoTypeForField(field, service), field.TagJSON()))
				}
				buf.WriteString("}\n\n")
			}

			if len(endpoint.Request.QueryParams) > 0 {
				buf.WriteString(fmt.Sprintf("type %s struct {\n", endpoint.GetQueryParamsType(resource.Name)))
				for _, field := range endpoint.Request.QueryParams {
					buf.WriteString(fmt.Sprintf("\t%s %s `form:\"%s\"`\n", field.Name, getGoTypeForField(field, service), field.TagJSON()))
				}
				buf.WriteString("}\n\n")
			}

			if len(endpoint.Request.BodyParams) > 0 {
				buf.WriteString(fmt.Sprintf("type %s struct {\n", endpoint.GetBodyParamsType(resource.Name)))
				for _, field := range endpoint.Request.BodyParams {
					buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", field.Name, getGoTypeForField(field, service), field.TagJSON()))
				}
				buf.WriteString("}\n\n")
			}
		}
	}

	// Generate endpoint-specific request types
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			buf.WriteString(fmt.Sprintf("type %s[Session any] Request[Session, %s, %s, %s]\n\n",
				endpoint.GetRequestType(resource.Name),
				endpoint.GetPathParamsType(resource.Name),
				endpoint.GetQueryParamsType(resource.Name),
				endpoint.GetBodyParamsType(resource.Name),
			))
		}
	}

	return nil
}

// getGoTypeForField converts a specification field to its Go type representation.
func getGoTypeForField(field specification.Field, service *specification.Service) string {
	fieldType := field.Type

	// Handle type prefix based on modifiers and whether it's an object/enum
	typePrefix := getTypePrefix(field, service)

	return typePrefix + fieldType
}

// getTypePrefix returns the appropriate type prefix for a field.
func getTypePrefix(field specification.Field, service *specification.Service) string {
	isObject := service.IsObject(field.Type)
	isEnum := service.HasEnum(field.Type)

	prefixes := []string{}

	if field.IsArray() {
		prefixes = append(prefixes, "[]")
	}

	if field.IsNullable() && isObject {
		prefixes = append(prefixes, "*")
	}

	if !isObject && !isEnum {
		prefixes = append(prefixes, "types.")
	}

	return strings.Join(prefixes, "")
}

// generateEndpointTest generates a test function for a specific endpoint.
func generateEndpointTest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	serviceName := strmangle.TitleCase(service.Name)
	testName := fmt.Sprintf("Test%s%s", resource.Name, endpoint.Name)

	buf.WriteString(fmt.Sprintf("// %s tests the %s endpoint for %s\n", testName, endpoint.Name, resource.Name))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testName))
	buf.WriteString("\tt.Run(\"Request\", func(t *testing.T) {\n")

	// Generate test setup
	err := generateTestSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate mock setup
	err = generateMockSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate server setup
	err = generateServerSetup(buf, serviceName, resource)
	if err != nil {
		return err
	}

	// Generate HTTP request
	err = generateHTTPRequest(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate assertions
	err = generateAssertions(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateTestSetup generates the test setup section.
func generateTestSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Arrange\n")
	buf.WriteString("\t\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\t\tctx := context.Background()\n\n")

	// Generate test data for path parameters
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Path parameters\n")
		for _, param := range endpoint.Request.PathParams {
			err := generateTestParameterValue(buf, param, "path")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")
	}

	// Generate test data for query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Query parameters\n")
		for _, param := range endpoint.Request.QueryParams {
			err := generateTestParameterValue(buf, param, "query")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")
	}

	// Generate test data for body parameters
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Body parameters\n")
		err := generateTestBody(buf, endpoint.Request.BodyParams)
		if err != nil {
			return err
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateTestParameterValue generates a test value for a parameter.
func generateTestParameterValue(buf *bytes.Buffer, param specification.Field, paramType string) error {
	varName := fmt.Sprintf("test%s%s", strmangle.TitleCase(paramType), strmangle.TitleCase(param.Name))

	switch param.Type {
	case "UUID":
		buf.WriteString(fmt.Sprintf("\t\t%s := uuid.New().String()\n", varName))
	case "String":
		defaultValue := "test-value"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	case "Int":
		defaultValue := "123"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := %s\n", varName, defaultValue))
	case "Bool":
		defaultValue := "true"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := %s\n", varName, defaultValue))
	default:
		// For custom types, generate a basic string value
		buf.WriteString(fmt.Sprintf("\t\t%s := \"test-%s-value\"\n", varName, strings.ToLower(param.Name)))
	}

	return nil
}

// generateTestBody generates test data for request body.
func generateTestBody(buf *bytes.Buffer, bodyParams []specification.Field) error {
	buf.WriteString("\t\ttestBody := map[string]interface{}{\n")

	for _, param := range bodyParams {
		jsonKey := getJSONKey(param.Name)

		switch param.Type {
		case "UUID":
			buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": uuid.New().String(),\n", jsonKey))
		case "String":
			defaultValue := "test-value"
			if param.Example != "" {
				defaultValue = param.Example
			}
			buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
		case "Int":
			defaultValue := "123"
			if param.Example != "" {
				defaultValue = param.Example
			}
			buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": %s,\n", jsonKey, defaultValue))
		case "Bool":
			defaultValue := "true"
			if param.Example != "" {
				defaultValue = param.Example
			}
			buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": %s,\n", jsonKey, defaultValue))
		default:
			buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"test-%s-value\",\n", jsonKey, strings.ToLower(param.Name)))
		}
	}

	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\ttestBodyBytes, err := json.Marshal(testBody)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal test body\")\n")

	return nil
}

// generateMockSetup generates mock service setup that captures the request for parameter validation.
func generateMockSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	requestType := endpoint.GetRequestType(resource.Name)
	buf.WriteString("\t\t// Mock service setup\n")
	buf.WriteString(fmt.Sprintf("\t\tvar capturedRequest %s[any]\n", requestType))
	buf.WriteString(fmt.Sprintf("\t\tmock%sAPI := &Mock%sAPI{}\n", resource.Name, resource.Name))

	// Generate method setup that captures the incoming request
	methodName := endpoint.Name

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)

		// For endpoints that return an object reference, use that object
		if endpoint.Response.BodyObject != nil {
			buf.WriteString(fmt.Sprintf("\t\texpected%s := &%s{\n", responseType, *endpoint.Response.BodyObject))
			buf.WriteString("\t\t\t// Add expected response fields here based on your needs\n")
			buf.WriteString("\t\t}\n")
		} else if len(endpoint.Response.BodyFields) > 0 {
			// For endpoints with response body fields, create response object
			buf.WriteString(fmt.Sprintf("\t\texpected%s := &%s{\n", responseType, responseType))
			buf.WriteString("\t\t\t// Add expected response fields here based on your needs\n")
			buf.WriteString("\t\t}\n")
		}

		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s[any]) (*%s, error) {\n",
			resource.Name, methodName, requestType, responseType))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString(fmt.Sprintf("\t\t\treturn expected%s, nil\n", responseType))
		buf.WriteString("\t\t}\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s[any]) error {\n",
			resource.Name, methodName, requestType))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString("\t\t\treturn nil\n")
		buf.WriteString("\t\t}\n")
	}

	buf.WriteString("\n")

	return nil
}

// generateServerSetup generates HTTP server setup.
func generateServerSetup(buf *bytes.Buffer, serviceName string, resource specification.Resource) error {
	buf.WriteString("\t\t// Server setup\n")
	buf.WriteString("\t\trouter := gin.New()\n")
	buf.WriteString(fmt.Sprintf("\t\tapi := &%sAPI[any]{\n", serviceName))
	buf.WriteString("\t\t\tServer: Server[any]{\n")
	buf.WriteString("\t\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\t\t\treturn testSessionUserID, nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tConvertErrorFunc: func(err error, requestID string) *Error {\n")
	buf.WriteString("\t\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t\t\t}\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString(fmt.Sprintf("\t\t\t%s: mock%sAPI,\n", resource.Name, resource.Name))
	buf.WriteString("\t\t}\n")
	buf.WriteString(fmt.Sprintf("\t\tRegister%sAPI(router, api)\n", serviceName))
	buf.WriteString("\t\tserver := httptest.NewServer(router)\n")
	buf.WriteString("\t\tdefer server.Close()\n\n")

	return nil
}

// generateHTTPRequest generates the HTTP request execution.
func generateHTTPRequest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Act - Execute HTTP request\n")

	// Build URL
	path := endpoint.GetFullPath(resource.Name)
	buf.WriteString(fmt.Sprintf("\t\trequestURL := server.URL + \"/%s/%s%s\"\n", service.PathName(), service.Version, path))

	// Replace path parameters with actual values
	if len(endpoint.Request.PathParams) > 0 {
		for _, param := range endpoint.Request.PathParams {
			paramName := fmt.Sprintf("{%s}", strings.ToLower(param.Name))
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			buf.WriteString(fmt.Sprintf("\t\trequestURL = strings.ReplaceAll(requestURL, \"%s\", %s)\n", paramName, varName))
		}
	}

	// Add query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Add query parameters\n")
		buf.WriteString("\t\tquery := url.Values{}\n")
		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tquery.Add(\"%s\", fmt.Sprintf(\"%%v\", %s))\n", jsonKey, varName))
		}
		buf.WriteString("\t\tif len(query) > 0 {\n")
		buf.WriteString("\t\t\trequestURL += \"?\" + query.Encode()\n")
		buf.WriteString("\t\t}\n")
	}

	// Create request
	method := strings.ToUpper(endpoint.Method)
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, bytes.NewBuffer(testBodyBytes))\n", method))
	} else {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, nil)\n", method))
	}

	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create HTTP request\")\n")

	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	}

	// Execute request
	buf.WriteString("\t\tresp, err := http.DefaultClient.Do(req)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to execute HTTP request\")\n")
	buf.WriteString("\t\tdefer resp.Body.Close()\n\n")

	return nil
}

// generateAssertions generates test assertions.
func generateAssertions(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Assert\n")
	buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %d, resp.StatusCode, \"Expected HTTP status %d\")\n",
		endpoint.Response.StatusCode, endpoint.Response.StatusCode))

	if endpoint.HasResponseType() {
		buf.WriteString("\t\t// Verify response body\n")
		buf.WriteString("\t\tvar responseBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.NewDecoder(resp.Body).Decode(&responseBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to decode response body\")\n")
		buf.WriteString("\t\tassert.NotNil(t, responseBody, \"Response body should not be nil\")\n")
	}

	// Verify the request was captured and has correct parameters
	buf.WriteString("\t\t// Verify request parameters were passed correctly\n")
	buf.WriteString("\t\tassert.NotNil(t, capturedRequest, \"Request should have been captured\")\n\n")

	// Assert path parameters
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Verify path parameters\n")
		for _, param := range endpoint.Request.PathParams {
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			fieldName := strmangle.TitleCase(param.Name)

			if param.IsArray() {
				// Handle array parameters
				buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.PathParams.%s, \"Path parameter %s should match\")\n",
					varName, fieldName, param.Name))
			} else {
				// Handle single value parameters
				switch param.Type {
				case "UUID":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.PathParams.%s.String(), \"Path parameter %s should match\")\n",
						varName, fieldName, param.Name))
				case "String":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.PathParams.%s.String(), \"Path parameter %s should match\")\n",
						varName, fieldName, param.Name))
				case "Int":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.PathParams.%s.Int(), \"Path parameter %s should match\")\n",
						varName, fieldName, param.Name))
				case "Bool":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.PathParams.%s.Bool(), \"Path parameter %s should match\")\n",
						varName, fieldName, param.Name))
				default:
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.PathParams.%s, \"Path parameter %s should match\")\n",
						varName, fieldName, param.Name))
				}
			}
		}
		buf.WriteString("\n")
	}

	// Assert query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Verify query parameters\n")
		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			fieldName := strmangle.TitleCase(param.Name)

			if param.IsArray() {
				// Handle array parameters
				buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.QueryParams.%s, \"Query parameter %s should match\")\n",
					varName, fieldName, param.Name))
			} else {
				// Handle single value parameters
				switch param.Type {
				case "UUID":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.QueryParams.%s.String(), \"Query parameter %s should match\")\n",
						varName, fieldName, param.Name))
				case "String":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.QueryParams.%s.String(), \"Query parameter %s should match\")\n",
						varName, fieldName, param.Name))
				case "Int":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.QueryParams.%s.Int(), \"Query parameter %s should match\")\n",
						varName, fieldName, param.Name))
				case "Bool":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.QueryParams.%s.Bool(), \"Query parameter %s should match\")\n",
						varName, fieldName, param.Name))
				default:
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedRequest.QueryParams.%s, \"Query parameter %s should match\")\n",
						varName, fieldName, param.Name))
				}
			}
		}
		buf.WriteString("\n")
	}

	// Assert body parameters
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Verify body parameters\n")
		for _, param := range endpoint.Request.BodyParams {
			fieldName := strmangle.TitleCase(param.Name)
			jsonKey := getJSONKey(param.Name)

			if param.IsArray() {
				// Handle array parameters
				buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequest.BodyParams.%s, \"Body parameter %s should match\")\n",
					jsonKey, fieldName, param.Name))
			} else {
				// Handle single value parameters
				switch param.Type {
				case "UUID":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequest.BodyParams.%s.String(), \"Body parameter %s should match\")\n",
						jsonKey, fieldName, param.Name))
				case "String":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequest.BodyParams.%s.String(), \"Body parameter %s should match\")\n",
						jsonKey, fieldName, param.Name))
				case "Int":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequest.BodyParams.%s.Int(), \"Body parameter %s should match\")\n",
						jsonKey, fieldName, param.Name))
				case "Bool":
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequest.BodyParams.%s.Bool(), \"Body parameter %s should match\")\n",
						jsonKey, fieldName, param.Name))
				default:
					buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequest.BodyParams.%s, \"Body parameter %s should match\")\n",
						jsonKey, fieldName, param.Name))
				}
			}
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateHelperFunctions generates helper functions and mock interfaces.
func generateHelperFunctions(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Mock interfaces and helper functions\n")
	buf.WriteString("// ============================================================================\n\n")

	// Generate mock interfaces for each resource
	for _, resource := range service.Resources {
		if len(resource.Endpoints) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("// Mock%sAPI is a mock implementation of %sAPI\n", resource.Name, resource.Name))
		buf.WriteString(fmt.Sprintf("type Mock%sAPI struct {\n", resource.Name))

		// Generate function fields for each endpoint
		for _, endpoint := range resource.Endpoints {
			methodName := endpoint.Name
			requestType := endpoint.GetRequestType(resource.Name)

			if endpoint.HasResponseType() {
				responseType := endpoint.GetResponseType(resource.Name)
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s[any]) (*%s, error)\n",
					methodName, requestType, responseType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s[any]) error\n",
					methodName, requestType))
			}
		}

		buf.WriteString("}\n\n")

		// Generate mock methods for each endpoint
		for _, endpoint := range resource.Endpoints {
			err := generateMockMethod(buf, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// generateMockMethod generates a mock method for an endpoint.
func generateMockMethod(buf *bytes.Buffer, resource specification.Resource, endpoint specification.Endpoint) error {
	methodName := endpoint.Name
	requestType := endpoint.GetRequestType(resource.Name)

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s[any]) (*%s, error) {\n",
			resource.Name, methodName, requestType, responseType))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString(fmt.Sprintf("\treturn nil, nil\n"))
	} else {
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s[any]) error {\n",
			resource.Name, methodName, requestType))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil\n")
	}

	buf.WriteString("}\n\n")

	return nil
}

// getJSONKey converts a field name to its JSON key (camelCase).
func getJSONKey(fieldName string) string {
	return specification.CamelCase(fieldName)
}
