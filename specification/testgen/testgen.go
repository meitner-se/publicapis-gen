package testgen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/aarondl/strmangle"
	"github.com/meitner-se/publicapis-gen/specification"
)

const (
	disclaimerComment = "// Code generated by publicapis-gen testgen. DO NOT EDIT.\n// This file is automatically generated from the API specification.\n// Any changes made to this file will be overwritten on the next generation.\n\n"
)

// GenerateTests generates HTTP API tests from a service specification.
func GenerateTests(buf *bytes.Buffer, service *specification.Service, packageName string) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports
	err := generateImports(buf)
	if err != nil {
		return err
	}

	// Generate test constants
	err = generateTestConstants(buf, service)
	if err != nil {
		return err
	}

	// Generate tests for each resource endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			err = generateEndpointTest(buf, service, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	// Generate helper functions
	err = generateHelperFunctions(buf, service)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

// generateImports generates the import section for the test file.
func generateImports(buf *bytes.Buffer) error {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString("\t\"testing\"\n\n")
	buf.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString("\t\"github.com/meitner-se/go-types\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/assert\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/mock\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateTestConstants generates constants used across tests.
func generateTestConstants(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// Test constants\n")
	buf.WriteString("const (\n")
	buf.WriteString("\ttestRequestID = \"test-request-id-123\"\n")
	buf.WriteString("\ttestSessionUserID = \"test-session-user-id\"\n")
	buf.WriteString("\ttestTimeout = \"30s\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateEndpointTest generates a test function for a specific endpoint.
func generateEndpointTest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	serviceName := strmangle.TitleCase(service.Name)
	testName := fmt.Sprintf("Test%s%s", resource.Name, endpoint.Name)

	buf.WriteString(fmt.Sprintf("// %s tests the %s endpoint for %s\n", testName, endpoint.Name, resource.Name))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testName))

	// Generate test setup
	err := generateTestSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate mock setup
	err = generateMockSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate server setup
	err = generateServerSetup(buf, serviceName, resource)
	if err != nil {
		return err
	}

	// Generate HTTP request
	err = generateHTTPRequest(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate assertions
	err = generateAssertions(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	buf.WriteString("}\n\n")

	return nil
}

// generateTestSetup generates the test setup section.
func generateTestSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t// Arrange\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tctx := context.Background()\n\n")

	// Generate test data for path parameters
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t// Path parameters\n")
		for _, param := range endpoint.Request.PathParams {
			err := generateTestParameterValue(buf, param, "path")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")
	}

	// Generate test data for query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t// Query parameters\n")
		for _, param := range endpoint.Request.QueryParams {
			err := generateTestParameterValue(buf, param, "query")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")
	}

	// Generate test data for body parameters
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t// Body parameters\n")
		err := generateTestBody(buf, endpoint.Request.BodyParams)
		if err != nil {
			return err
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateTestParameterValue generates a test value for a parameter.
func generateTestParameterValue(buf *bytes.Buffer, param specification.Field, paramType string) error {
	varName := fmt.Sprintf("test%s%s", strmangle.TitleCase(paramType), strmangle.TitleCase(param.Name))

	switch param.Type {
	case "UUID":
		buf.WriteString(fmt.Sprintf("\t%s := uuid.New().String()\n", varName))
	case "String":
		defaultValue := "test-value"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t%s := \"%s\"\n", varName, defaultValue))
	case "Int":
		defaultValue := "123"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t%s := %s\n", varName, defaultValue))
	case "Bool":
		defaultValue := "true"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t%s := %s\n", varName, defaultValue))
	default:
		// For custom types, generate a basic string value
		buf.WriteString(fmt.Sprintf("\t%s := \"test-%s-value\"\n", varName, strings.ToLower(param.Name)))
	}

	return nil
}

// generateTestBody generates test data for request body.
func generateTestBody(buf *bytes.Buffer, bodyParams []specification.Field) error {
	buf.WriteString("\ttestBody := map[string]interface{}{\n")

	for _, param := range bodyParams {
		jsonKey := getJSONKey(param.Name)

		switch param.Type {
		case "UUID":
			buf.WriteString(fmt.Sprintf("\t\t\"%s\": uuid.New().String(),\n", jsonKey))
		case "String":
			defaultValue := "test-value"
			if param.Example != "" {
				defaultValue = param.Example
			}
			buf.WriteString(fmt.Sprintf("\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
		case "Int":
			defaultValue := "123"
			if param.Example != "" {
				defaultValue = param.Example
			}
			buf.WriteString(fmt.Sprintf("\t\t\"%s\": %s,\n", jsonKey, defaultValue))
		case "Bool":
			defaultValue := "true"
			if param.Example != "" {
				defaultValue = param.Example
			}
			buf.WriteString(fmt.Sprintf("\t\t\"%s\": %s,\n", jsonKey, defaultValue))
		default:
			buf.WriteString(fmt.Sprintf("\t\t\"%s\": \"test-%s-value\",\n", jsonKey, strings.ToLower(param.Name)))
		}
	}

	buf.WriteString("\t}\n")
	buf.WriteString("\ttestBodyBytes, err := json.Marshal(testBody)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to marshal test body\")\n")

	return nil
}

// generateMockSetup generates mock service setup.
func generateMockSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t// Mock service setup\n")
	buf.WriteString(fmt.Sprintf("\tmock%sAPI := &Mock%sAPI{}\n", resource.Name, resource.Name))

	// Generate expected method call setup
	methodName := endpoint.Name
	requestType := endpoint.GetRequestType(resource.Name)

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)

		// For endpoints that return an object reference, use that object
		if endpoint.Response.BodyObject != nil {
			buf.WriteString(fmt.Sprintf("\texpected%s := &%s{\n", responseType, *endpoint.Response.BodyObject))
			buf.WriteString("\t\t// Add expected response fields here based on your needs\n")
			buf.WriteString("\t}\n")
		} else if len(endpoint.Response.BodyFields) > 0 {
			// For endpoints with response body fields, create response object
			buf.WriteString(fmt.Sprintf("\texpected%s := &%s{\n", responseType, responseType))
			buf.WriteString("\t\t// Add expected response fields here based on your needs\n")
			buf.WriteString("\t}\n")
		}

		buf.WriteString(fmt.Sprintf("\tmock%sAPI.On(\"%s\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"%s[any]\")).Return(expected%s, nil)\n",
			resource.Name, methodName, requestType, responseType))
	} else {
		buf.WriteString(fmt.Sprintf("\tmock%sAPI.On(\"%s\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"%s[any]\")).Return(nil)\n",
			resource.Name, methodName, requestType))
	}

	buf.WriteString("\n")

	return nil
}

// generateServerSetup generates HTTP server setup.
func generateServerSetup(buf *bytes.Buffer, serviceName string, resource specification.Resource) error {
	buf.WriteString("\t// Server setup\n")
	buf.WriteString("\trouter := gin.New()\n")
	buf.WriteString(fmt.Sprintf("\tapi := &%sAPI[any]{\n", serviceName))
	buf.WriteString("\t\tServer: Server[any]{\n")
	buf.WriteString("\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\t\treturn testSessionUserID, nil\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t\tConvertErrorFunc: func(err error, requestID string) *Error {\n")
	buf.WriteString("\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t\t}\n")
	buf.WriteString("\t\t\t},\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString(fmt.Sprintf("\t\t%s: mock%sAPI,\n", resource.Name, resource.Name))
	buf.WriteString("\t}\n")
	buf.WriteString(fmt.Sprintf("\tRegister%sAPI(router, api)\n", serviceName))
	buf.WriteString("\tserver := httptest.NewServer(router)\n")
	buf.WriteString("\tdefer server.Close()\n\n")

	return nil
}

// generateHTTPRequest generates the HTTP request execution.
func generateHTTPRequest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t// Act - Execute HTTP request\n")

	// Build URL
	path := endpoint.GetFullPath(resource.Name)
	buf.WriteString(fmt.Sprintf("\turl := server.URL + \"/%s/%s%s\"\n", service.PathName(), service.Version, path))

	// Replace path parameters with actual values
	if len(endpoint.Request.PathParams) > 0 {
		for _, param := range endpoint.Request.PathParams {
			paramName := fmt.Sprintf("{%s}", strings.ToLower(param.Name))
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			buf.WriteString(fmt.Sprintf("\turl = strings.ReplaceAll(url, \"%s\", %s)\n", paramName, varName))
		}
	}

	// Add query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t// Add query parameters\n")
		buf.WriteString("\tquery := url.Values{}\n")
		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\tquery.Add(\"%s\", fmt.Sprintf(\"%%v\", %s))\n", jsonKey, varName))
		}
		buf.WriteString("\tif len(query) > 0 {\n")
		buf.WriteString("\t\turl += \"?\" + query.Encode()\n")
		buf.WriteString("\t}\n")
	}

	// Create request
	method := strings.ToUpper(endpoint.Method)
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString(fmt.Sprintf("\treq, err := http.NewRequestWithContext(ctx, \"%s\", url, bytes.NewBuffer(testBodyBytes))\n", method))
	} else {
		buf.WriteString(fmt.Sprintf("\treq, err := http.NewRequestWithContext(ctx, \"%s\", url, nil)\n", method))
	}

	buf.WriteString("\tassert.NoError(t, err, \"Failed to create HTTP request\")\n")

	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	}

	// Execute request
	buf.WriteString("\tresp, err := http.DefaultClient.Do(req)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to execute HTTP request\")\n")
	buf.WriteString("\tdefer resp.Body.Close()\n\n")

	return nil
}

// generateAssertions generates test assertions.
func generateAssertions(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t// Assert\n")
	buf.WriteString(fmt.Sprintf("\tassert.Equal(t, %d, resp.StatusCode, \"Expected HTTP status %d\")\n",
		endpoint.Response.StatusCode, endpoint.Response.StatusCode))

	if endpoint.HasResponseType() {
		buf.WriteString("\t// Verify response body\n")
		buf.WriteString("\tvar responseBody map[string]interface{}\n")
		buf.WriteString("\terr = json.NewDecoder(resp.Body).Decode(&responseBody)\n")
		buf.WriteString("\tassert.NoError(t, err, \"Failed to decode response body\")\n")
		buf.WriteString("\tassert.NotNil(t, responseBody, \"Response body should not be nil\")\n")
	}

	// Verify mock was called
	buf.WriteString(fmt.Sprintf("\t// Verify mock was called correctly\n"))
	buf.WriteString(fmt.Sprintf("\tmock%sAPI.AssertExpectations(t)\n", resource.Name))
	buf.WriteString(fmt.Sprintf("\tmock%sAPI.AssertCalled(t, \"%s\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"%s[any]\"))\n",
		resource.Name, endpoint.Name, endpoint.GetRequestType(resource.Name)))

	return nil
}

// generateHelperFunctions generates helper functions and mock interfaces.
func generateHelperFunctions(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Mock interfaces and helper functions\n")
	buf.WriteString("// ============================================================================\n\n")

	// Generate mock interfaces for each resource
	for _, resource := range service.Resources {
		if len(resource.Endpoints) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("// Mock%sAPI is a mock implementation of %sAPI\n", resource.Name, resource.Name))
		buf.WriteString(fmt.Sprintf("type Mock%sAPI struct {\n", resource.Name))
		buf.WriteString("\tmock.Mock\n")
		buf.WriteString("}\n\n")

		// Generate mock methods for each endpoint
		for _, endpoint := range resource.Endpoints {
			err := generateMockMethod(buf, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// generateMockMethod generates a mock method for an endpoint.
func generateMockMethod(buf *bytes.Buffer, resource specification.Resource, endpoint specification.Endpoint) error {
	methodName := endpoint.Name
	requestType := endpoint.GetRequestType(resource.Name)

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s[any]) (*%s, error) {\n",
			resource.Name, methodName, requestType, responseType))
		buf.WriteString("\targs := m.Called(ctx, request)\n")
		buf.WriteString(fmt.Sprintf("\treturn args.Get(0).(*%s), args.Error(1)\n", responseType))
	} else {
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s[any]) error {\n",
			resource.Name, methodName, requestType))
		buf.WriteString("\targs := m.Called(ctx, request)\n")
		buf.WriteString("\treturn args.Error(0)\n")
	}

	buf.WriteString("}\n\n")

	return nil
}

// getJSONKey converts a field name to its JSON key (camelCase).
func getJSONKey(fieldName string) string {
	return specification.CamelCase(fieldName)
}
