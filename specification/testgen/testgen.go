package testgen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/aarondl/strmangle"
	"github.com/meitner-se/publicapis-gen/specification"
)

const (
	disclaimerComment = "// Code generated by publicapis-gen testgen. DO NOT EDIT.\n// This file is automatically generated from the API specification.\n// Any changes made to this file will be overwritten on the next generation.\n\n"
)

// GenerateInternalTests generates internal HTTP API tests from a service specification.
func GenerateInternalTests(buf *bytes.Buffer, service *specification.Service, packageName string) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports (no API package import needed for internal tests)
	err := generateInternalImports(buf)
	if err != nil {
		return err
	}

	// Generate test constants
	err = generateTestConstants(buf, service)
	if err != nil {
		return err
	}

	// Generate tests for each resource endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			err = generateInternalEndpointTest(buf, service, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	// Generate helper functions (no API package prefixes needed)
	err = generateInternalHelperFunctions(buf, service)
	if err != nil {
		return err
	}

	// Generate utility function tests (no API package prefixes needed)
	err = generateInternalUtilityTests(buf, service)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

// GenerateTests generates HTTP API tests from a service specification.
func GenerateTests(buf *bytes.Buffer, service *specification.Service, packageName string, apiPackageName string, apiPackageImport string) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports
	err := generateImports(buf, apiPackageName, apiPackageImport)
	if err != nil {
		return err
	}

	// Generate test constants
	err = generateTestConstants(buf, service)
	if err != nil {
		return err
	}

	// Generate tests for each resource endpoint
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			err = generateEndpointTest(buf, service, resource, endpoint, apiPackageName)
			if err != nil {
				return err
			}
		}
	}

	// Generate helper functions
	err = generateHelperFunctions(buf, service, apiPackageName)
	if err != nil {
		return err
	}

	// Generate utility function tests
	err = generateUtilityTests(buf, service, apiPackageName)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

// generateInternalImports generates the import section for internal test files.
func generateInternalImports(buf *bytes.Buffer) error {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString("\t\"testing\"\n\n")
	buf.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString("\t\"github.com/meitner-se/go-types\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/assert\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateImports generates the import section for the test file.
func generateImports(buf *bytes.Buffer, apiPackageName string, apiPackageImport string) error {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"net/url\"\n")
	buf.WriteString("\t\"strings\"\n")
	buf.WriteString("\t\"testing\"\n\n")
	buf.WriteString("\t\"github.com/gin-gonic/gin\"\n")
	buf.WriteString("\t\"github.com/google/uuid\"\n")
	buf.WriteString("\t\"github.com/meitner-se/go-types\"\n")
	buf.WriteString("\t\"github.com/stretchr/testify/assert\"\n")
	if apiPackageImport != "" {
		if apiPackageName != "" && apiPackageName != "api" {
			buf.WriteString(fmt.Sprintf("\t%s \"%s\"\n", apiPackageName, apiPackageImport))
		} else {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", apiPackageImport))
		}
	}
	buf.WriteString(")\n\n")

	return nil
}

// generateTestConstants generates constants used across tests.
func generateTestConstants(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// Test constants\n")
	buf.WriteString("const (\n")
	buf.WriteString("\ttestRequestID = \"test-request-id-123\"\n")
	buf.WriteString("\ttestSessionUserID = \"test-session-user-id\"\n")
	buf.WriteString("\ttestTimeout = \"30s\"\n")
	buf.WriteString(")\n\n")

	return nil
}

// generateEndpointTest generates a test function for a specific endpoint.
func generateEndpointTest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	serviceName := strmangle.TitleCase(service.Name)
	testName := fmt.Sprintf("Test%s%s", resource.Name, endpoint.Name)

	buf.WriteString(fmt.Sprintf("// %s tests the %s endpoint for %s\n", testName, endpoint.Name, resource.Name))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testName))
	buf.WriteString("\tt.Run(\"Request\", func(t *testing.T) {\n")

	// Generate test setup (without parameters)
	err := generateTestSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate mock setup
	err = generateMockSetup(buf, service, resource, endpoint, apiPackageName)
	if err != nil {
		return err
	}

	// Generate server setup
	err = generateServerSetup(buf, serviceName, service, resource, endpoint, apiPackageName)
	if err != nil {
		return err
	}

	// Generate HTTP request (with parameters defined inline)
	err = generateHTTPRequest(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate assertions
	err = generateAssertions(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateTestSetup generates the test setup section.
func generateTestSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Arrange\n")
	buf.WriteString("\t\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\t\tctx := context.Background()\n\n")

	return nil
}

// generateTestParameterValue generates a test value for a parameter.
func generateTestParameterValue(buf *bytes.Buffer, param specification.Field, paramType string) error {
	varName := fmt.Sprintf("test%s%s", strmangle.TitleCase(paramType), strmangle.TitleCase(param.Name))

	switch param.Type {
	case "UUID":
		buf.WriteString(fmt.Sprintf("\t\t%s := uuid.New().String()\n", varName))
	case "String":
		defaultValue := "test-value"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	case "Int":
		defaultValue := "123"
		if param.Example != "" {
			defaultValue = param.Example
		}
		// Use float64 for consistency with JSON unmarshaling
		buf.WriteString(fmt.Sprintf("\t\t%s := float64(%s)\n", varName, defaultValue))
	case "Bool":
		defaultValue := "true"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := %s\n", varName, defaultValue))
	case "Date":
		defaultValue := "2024-01-15"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	case "Timestamp":
		defaultValue := "2024-01-15T10:30:00Z"
		if param.Example != "" {
			defaultValue = param.Example
		}
		buf.WriteString(fmt.Sprintf("\t\t%s := \"%s\"\n", varName, defaultValue))
	default:
		// For custom types, generate a basic string value
		buf.WriteString(fmt.Sprintf("\t\t%s := \"test-%s-value\"\n", varName, strings.ToLower(param.Name)))
	}

	return nil
}

// generateTestBody generates test data for request body.
func generateTestBody(buf *bytes.Buffer, bodyParams []specification.Field, service *specification.Service) error {
	buf.WriteString("\t\ttestBody := map[string]interface{}{\n")

	for _, param := range bodyParams {
		jsonKey := getJSONKey(param.Name)

		if param.IsArray() {
			// Handle array types
			switch param.Type {
			case "UUID":
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{uuid.New().String()},\n", jsonKey))
			case "String":
				defaultValue := "test-value"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			case "Int":
				defaultValue := "123"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{float64(%s)},\n", jsonKey, defaultValue))
			case "Bool":
				defaultValue := "true"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{%s},\n", jsonKey, defaultValue))
			case "Date":
				defaultValue := "2024-01-15"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			case "Timestamp":
				defaultValue := "2024-01-15T10:30:00Z"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"%s\"},\n", jsonKey, defaultValue))
			default:
				// For custom object arrays, create an array with one test object
				if service.IsObject(param.Type) {
					visited := make(map[string]bool)
					objectFields := getObjectTestDataWithVisited(param.Type, service, visited)
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{map[string]interface{}{%s}},\n", jsonKey, objectFields))
				} else {
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": []interface{}{\"test-%s-value\"},\n", jsonKey, strings.ToLower(param.Name)))
				}
			}
		} else {
			// Handle single value types
			switch param.Type {
			case "UUID":
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": uuid.New().String(),\n", jsonKey))
			case "String":
				defaultValue := "test-value"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			case "Int":
				defaultValue := "123"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": float64(%s),\n", jsonKey, defaultValue))
			case "Bool":
				defaultValue := "true"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": %s,\n", jsonKey, defaultValue))
			case "Date":
				defaultValue := "2024-01-15"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			case "Timestamp":
				defaultValue := "2024-01-15T10:30:00Z"
				if param.Example != "" {
					defaultValue = param.Example
				}
				buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"%s\",\n", jsonKey, defaultValue))
			default:
				// For custom object types, create a nested object
				if service.IsObject(param.Type) {
					visited := make(map[string]bool)
					objectFields := getObjectTestDataWithVisited(param.Type, service, visited)
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": map[string]interface{}{%s},\n", jsonKey, objectFields))
				} else {
					// For enums or unknown types, use string
					buf.WriteString(fmt.Sprintf("\t\t\t\"%s\": \"test-%s-value\",\n", jsonKey, strings.ToLower(param.Name)))
				}
			}
		}
	}

	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\ttestBodyBytes, err := json.Marshal(testBody)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal test body\")\n")

	return nil
}

// generateMockSetup generates mock service setup that captures the request for parameter validation.
func generateMockSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	buf.WriteString("\t\t// Mock service setup\n")
	buf.WriteString(fmt.Sprintf("\t\tvar capturedRequest %s.Request[any, %s, %s, %s]\n",
		apiPackageName,
		getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
		getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
		getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))

	// The mock configuration is now handled in generateServerSetup
	// This function just declares the captured request variable

	return nil
}

// generateServerSetup generates HTTP server setup.
func generateServerSetup(buf *bytes.Buffer, serviceName string, service *specification.Service, currentResource specification.Resource, currentEndpoint specification.Endpoint, apiPackageName string) error {
	buf.WriteString("\t\t// Server setup\n")
	buf.WriteString("\t\trouter := gin.New()\n")

	// Create and configure only the mock for the resource being tested
	buf.WriteString(fmt.Sprintf("\t\tmock%sAPI := &Mock%sAPI{}\n", currentResource.Name, currentResource.Name))

	methodName := currentEndpoint.Name
	if currentEndpoint.HasResponseType() {
		responseType := currentEndpoint.GetResponseType(currentResource.Name)
		buf.WriteString(fmt.Sprintf("\t\texpected%s := &%s.%s{\n", responseType, apiPackageName, responseType))
		buf.WriteString("\t\t\t// Add expected response fields here based on your needs\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error) {\n",
			currentResource.Name, methodName, apiPackageName,
			getAPITypeReference(currentEndpoint.GetPathParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name), apiPackageName),
			apiPackageName, responseType))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString(fmt.Sprintf("\t\t\treturn expected%s, nil\n", responseType))
		buf.WriteString("\t\t}\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request %s.Request[any, %s, %s, %s]) error {\n",
			currentResource.Name, methodName, apiPackageName,
			getAPITypeReference(currentEndpoint.GetPathParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name), apiPackageName),
			getAPITypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name), apiPackageName)))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString("\t\t\treturn nil\n")
		buf.WriteString("\t\t}\n")
	}
	buf.WriteString("\n")

	buf.WriteString(fmt.Sprintf("\t\t%s.Register%sAPI(router, &%s.%sAPI[any]{\n", apiPackageName, serviceName, apiPackageName, serviceName))
	buf.WriteString(fmt.Sprintf("\t\t\tServer: %s.Server[any]{\n", apiPackageName))
	buf.WriteString("\t\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\t\t\treturn testSessionUserID, nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString(fmt.Sprintf("\t\t\t\tConvertErrorFunc: func(err error, requestID string) *%s.Error {\n", apiPackageName))
	buf.WriteString(fmt.Sprintf("\t\t\t\t\treturn &%s.Error{\n", apiPackageName))
	buf.WriteString(fmt.Sprintf("\t\t\t\t\t\tCode:      %s.ErrorCodeInternal,\n", apiPackageName))
	buf.WriteString("\t\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t\t\t}\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")

	// Add all resource mocks to the API struct
	for _, resource := range service.Resources {
		if len(resource.Endpoints) > 0 {
			if resource.Name == currentResource.Name {
				// Use the configured mock for the resource being tested
				buf.WriteString(fmt.Sprintf("\t\t\t%s: mock%sAPI,\n", resource.Name, resource.Name))
			} else {
				// Create inline mocks for other resources to prevent panics
				buf.WriteString(fmt.Sprintf("\t\t\t%s: &Mock%sAPI{},\n", resource.Name, resource.Name))
			}
		}
	}

	buf.WriteString("\t\t})\n")
	buf.WriteString("\t\tserver := httptest.NewServer(router)\n")
	buf.WriteString("\t\tdefer server.Close()\n\n")

	return nil
}

// generateHTTPRequest generates the HTTP request execution.
func generateHTTPRequest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Act - Execute HTTP request\n")

	// Build URL
	path := endpoint.GetFullPath(resource.Name)
	buf.WriteString(fmt.Sprintf("\t\trequestURL := server.URL + \"/%s/%s%s\"\n", service.PathName(), service.Version, path))

	// Generate and use path parameters
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Path parameters\n")
		for _, param := range endpoint.Request.PathParams {
			err := generateTestParameterValue(buf, param, "path")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")

		// Replace path parameters in URL
		for _, param := range endpoint.Request.PathParams {
			paramName := fmt.Sprintf("{%s}", strings.ToLower(param.Name))
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			buf.WriteString(fmt.Sprintf("\t\trequestURL = strings.ReplaceAll(requestURL, \"%s\", %s)\n", paramName, varName))
		}
		buf.WriteString("\n")
	}

	// Generate and use query parameters
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Query parameters\n")
		for _, param := range endpoint.Request.QueryParams {
			err := generateTestParameterValue(buf, param, "query")
			if err != nil {
				return err
			}
		}
		buf.WriteString("\n")

		buf.WriteString("\t\t// Add query parameters to URL\n")
		buf.WriteString("\t\tquery := url.Values{}\n")
		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tquery.Add(\"%s\", fmt.Sprintf(\"%%v\", %s))\n", jsonKey, varName))
		}
		buf.WriteString("\t\tif len(query) > 0 {\n")
		buf.WriteString("\t\t\trequestURL += \"?\" + query.Encode()\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\n")
	}

	// Generate and use body parameters
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Body parameters\n")
		err := generateTestBody(buf, endpoint.Request.BodyParams, service)
		if err != nil {
			return err
		}
		buf.WriteString("\n")
	}

	// Create request
	method := strings.ToUpper(endpoint.Method)
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, bytes.NewBuffer(testBodyBytes))\n", method))
	} else {
		buf.WriteString(fmt.Sprintf("\t\treq, err := http.NewRequestWithContext(ctx, \"%s\", requestURL, nil)\n", method))
	}

	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create HTTP request\")\n")

	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	}

	// Execute request
	buf.WriteString("\t\tresp, err := http.DefaultClient.Do(req)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to execute HTTP request\")\n")
	buf.WriteString("\t\tdefer resp.Body.Close()\n\n")

	return nil
}

// generateAssertions generates test assertions.
func generateAssertions(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Assert\n")
	buf.WriteString("\t\t// Read response body for debugging and verification\n")
	buf.WriteString("\t\tresponseBodyBytes, err := io.ReadAll(resp.Body)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to read response body\")\n\n")

	buf.WriteString("\t\t// Check status code and print response body if unexpected\n")
	buf.WriteString("\t\tif resp.StatusCode != " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + " {\n")
	buf.WriteString("\t\t\tt.Errorf(\"Expected HTTP status %d, got %d. Response body: %s\", " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + ", resp.StatusCode, string(responseBodyBytes))\n")
	buf.WriteString("\t\t\treturn\n")
	buf.WriteString("\t\t}\n\n")

	if endpoint.HasResponseType() {
		buf.WriteString("\t\t// Verify response body\n")
		buf.WriteString("\t\tvar responseBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(responseBodyBytes, &responseBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to decode response body\")\n")
		buf.WriteString("\t\tassert.NotNil(t, responseBody, \"Response body should not be nil\")\n")
	}

	// Verify the service method was called with the request
	buf.WriteString("\t\t// Verify service method was called (indicating HTTP request was processed)\n")
	buf.WriteString("\t\tassert.NotNil(t, capturedRequest, \"Service method should have been called with a request\")\n\n")

	// Assert path parameters by converting to JSON for easy comparison
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Verify path parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedPathBytes, err := json.Marshal(capturedRequest.PathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured path params\")\n")
		buf.WriteString("\t\tvar capturedPathParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedPathBytes, &capturedPathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured path params\")\n\n")

		for _, param := range endpoint.Request.PathParams {
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedPathParams[\"%s\"], \"Path parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert query parameters by converting to JSON for easy comparison
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Verify query parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedQueryBytes, err := json.Marshal(capturedRequest.QueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured query params\")\n")
		buf.WriteString("\t\tvar capturedQueryParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedQueryBytes, &capturedQueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured query params\")\n\n")

		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedQueryParams[\"%s\"], \"Query parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert body parameters by converting captured request body to JSON for easy comparison
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Verify body parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedBodyBytes, err := json.Marshal(capturedRequest.BodyParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured body params\")\n")
		buf.WriteString("\t\tvar capturedRequestBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedBodyBytes, &capturedRequestBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured body params\")\n\n")

		for _, param := range endpoint.Request.BodyParams {
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequestBody[\"%s\"], \"Body parameter %s should match\")\n",
				jsonKey, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateHelperFunctions generates helper functions and mock interfaces.
func generateHelperFunctions(buf *bytes.Buffer, service *specification.Service, apiPackageName string) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Mock interfaces and helper functions\n")
	buf.WriteString("// ============================================================================\n\n")

	// Generate mock interfaces for each resource
	for _, resource := range service.Resources {
		if len(resource.Endpoints) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("// Mock%sAPI is a mock implementation of %sAPI\n", resource.Name, resource.Name))
		buf.WriteString(fmt.Sprintf("type Mock%sAPI struct {\n", resource.Name))

		// Generate function fields for each endpoint
		for _, endpoint := range resource.Endpoints {
			methodName := endpoint.Name

			if endpoint.HasResponseType() {
				responseType := endpoint.GetResponseType(resource.Name)
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error)\n",
					methodName, apiPackageName,
					getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName),
					apiPackageName, responseType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request %s.Request[any, %s, %s, %s]) error\n",
					methodName, apiPackageName,
					getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
					getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))
			}
		}

		buf.WriteString("}\n\n")

		// Generate mock methods for each endpoint
		for _, endpoint := range resource.Endpoints {
			err := generateMockMethod(buf, resource, endpoint, apiPackageName)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// generateMockMethod generates a mock method for an endpoint.
func generateMockMethod(buf *bytes.Buffer, resource specification.Resource, endpoint specification.Endpoint, apiPackageName string) error {
	methodName := endpoint.Name

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s.Request[any, %s, %s, %s]) (*%s.%s, error) {\n",
			resource.Name, methodName, apiPackageName,
			getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName),
			apiPackageName, responseType))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString(fmt.Sprintf("\treturn nil, nil\n"))
	} else {
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request %s.Request[any, %s, %s, %s]) error {\n",
			resource.Name, methodName, apiPackageName,
			getAPITypeReference(endpoint.GetPathParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetQueryParamsType(resource.Name), apiPackageName),
			getAPITypeReference(endpoint.GetBodyParamsType(resource.Name), apiPackageName)))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil\n")
	}

	buf.WriteString("}\n\n")

	return nil
}

// getAPITypeReference adds the API package prefix to type names, except for built-in types like struct{}.
func getAPITypeReference(typeName string, apiPackageName string) string {
	if typeName == "struct{}" {
		return "struct{}"
	}
	return apiPackageName + "." + typeName
}

// getObjectTestData generates test data for a custom object type.
func getObjectTestData(objectType string, service *specification.Service) string {
	visited := make(map[string]bool)
	return getObjectTestDataWithVisited(objectType, service, visited)
}

// getObjectTestDataWithVisited generates test data for a custom object type with recursion protection.
func getObjectTestDataWithVisited(objectType string, service *specification.Service, visited map[string]bool) string {
	// Check for circular references
	if visited[objectType] {
		return "" // Avoid infinite recursion - return empty string for truly empty object
	}
	visited[objectType] = true

	// Find the object definition
	for _, obj := range service.Objects {
		if obj.Name == objectType {
			var fields []string
			for _, field := range obj.Fields {
				jsonKey := getJSONKey(field.Name)

				// Skip nullable fields to avoid nil value issues in test data
				if field.IsNullable() {
					continue
				}

				if field.IsArray() {
					// Handle array fields in objects
					switch field.Type {
					case "UUID":
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{uuid.New().String()}", jsonKey))
					case "String":
						defaultValue := "test-value"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					case "Int":
						defaultValue := "123"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{float64(%s)}", jsonKey, defaultValue))
					case "Bool":
						defaultValue := "true"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{%s}", jsonKey, defaultValue))
					case "Date":
						defaultValue := "2024-01-15"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					case "Timestamp":
						defaultValue := "2024-01-15T10:30:00Z"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"%s\"}", jsonKey, defaultValue))
					default:
						// For custom object arrays, create an array with one test object
						if service.IsObject(field.Type) {
							nestedObjectFields := getObjectTestDataWithVisited(field.Type, service, visited)
							if nestedObjectFields != "" {
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{map[string]interface{}{%s}}", jsonKey, nestedObjectFields))
							} else {
								// For circular references, create empty array
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{}", jsonKey))
							}
						} else {
							fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": []interface{}{\"test-%s-value\"}", jsonKey, strings.ToLower(field.Name)))
						}
					}
				} else {
					// Handle single value fields in objects
					switch field.Type {
					case "UUID":
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": uuid.New().String()", jsonKey))
					case "String":
						defaultValue := "test-value"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					case "Int":
						defaultValue := "123"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": float64(%s)", jsonKey, defaultValue))
					case "Bool":
						defaultValue := "true"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": %s", jsonKey, defaultValue))
					case "Date":
						defaultValue := "2024-01-15"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					case "Timestamp":
						defaultValue := "2024-01-15T10:30:00Z"
						if field.Example != "" {
							defaultValue = field.Example
						}
						fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"%s\"", jsonKey, defaultValue))
					default:
						// For nested objects, create proper object structure recursively
						if service.IsObject(field.Type) {
							nestedObjectFields := getObjectTestDataWithVisited(field.Type, service, visited)
							if nestedObjectFields != "" {
								fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": map[string]interface{}{%s}", jsonKey, nestedObjectFields))
							}
							// Skip circular references entirely - don't add field at all
						} else {
							// For enums, use string for simplicity
							fields = append(fields, fmt.Sprintf("\n\t\t\t\t\"%s\": \"test-%s-value\"", jsonKey, strings.ToLower(field.Name)))
						}
					}
				}
			}

			if len(fields) > 0 {
				return strings.Join(fields, ",") + ",\n\t\t\t"
			}
			return ""
		}
	}

	// If object not found, return empty
	return ""
}

// generateUtilityTests generates tests for utility functions.
func generateUtilityTests(buf *bytes.Buffer, service *specification.Service, apiPackageName string) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Utility function tests\n")
	buf.WriteString("// ============================================================================\n\n")

	// Test serveWithResponse
	err := generateServeWithResponseTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test serveWithoutResponse
	err = generateServeWithoutResponseTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test parseRequest
	err = generateParseRequestTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test decodeBodyParams
	err = generateDecodeBodyParamsTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test decodePathParams
	err = generateDecodePathParamsTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	// Test decodeQueryParams
	err = generateDecodeQueryParamsTest(buf, apiPackageName)
	if err != nil {
		return err
	}

	return nil
}

// generateServeWithResponseTest generates test for serveWithResponse function.
func generateServeWithResponseTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_serveWithResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that returns a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tConvertErrorFunc: func(err error, requestID string) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithResponse\n")
	buf.WriteString("\thandler := " + apiPackageName + ".ServeWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\tassert.Contains(t, w.Body.String(), \"success\", \"Expected success message\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateServeWithoutResponseTest generates test for serveWithoutResponse function.
func generateServeWithoutResponseTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_serveWithoutResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that doesn't return a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request " + apiPackageName + ".Request[any, struct{}, struct{}, struct{}]) error {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := " + apiPackageName + ".Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tConvertErrorFunc: func(err error, requestID string) *" + apiPackageName + ".Error {\n")
	buf.WriteString("\t\t\treturn &" + apiPackageName + ".Error{\n")
	buf.WriteString("\t\t\t\tCode:      " + apiPackageName + ".ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithoutResponse\n")
	buf.WriteString("\thandler := " + apiPackageName + ".ServeWithoutResponse(204, server, mockFunction)\n")
	buf.WriteString("\trouter.DELETE(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"DELETE\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 204, w.Code, \"Expected 204 status code\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateParseRequestTest generates test for parseRequest function.
func generateParseRequestTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_parseRequest(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	buf.WriteString("\tt.Run(\"successful request parsing\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n\n")

	buf.WriteString("\t\t// Create test request with JSON body\n")
	buf.WriteString("\t\ttestBody := `{\"name\": \"test\"}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test?limit=10&offset=0\", strings.NewReader(testBody))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n")
	buf.WriteString("\t\tc.Params = []gin.Param{{Key: \"id\", Value: \"123\"}}\n\n")

	buf.WriteString("\t\t// Mock session function\n")
	buf.WriteString("\t\tgetSession := func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test parseRequest\n")
	buf.WriteString("\t\trequest, apiError := " + apiPackageName + ".ParseRequest[any, struct{}, struct{}, struct{}](c, \"test-123\", getSession)\n")
	buf.WriteString("\t\tassert.Nil(t, apiError, \"Expected no error from parseRequest\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-session\", request.Session, \"Session should be set\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-123\", request.RequestID(), \"RequestID should be set\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"session function error returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Mock session function that returns error\n")
	buf.WriteString("\t\tgetSessionWithError := func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn nil, fmt.Errorf(\"authentication failed\")\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test parseRequest with session error\n")
	buf.WriteString("\t\t_, apiError := " + apiPackageName + ".ParseRequest[any, struct{}, struct{}, struct{}](c, \"test-456\", getSessionWithError)\n")
	buf.WriteString("\t\tassert.NotNil(t, apiError, \"Expected API error when session function fails\")\n")
	buf.WriteString("\t\tassert.Equal(t, " + apiPackageName + ".ErrorCodeUnauthorized, apiError.Code, \"Should return Unauthorized error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"authentication failed\", \"Error message should contain session error\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-456\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"invalid JSON body returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\t// Define test struct for body params\n")
	buf.WriteString("\t\ttype TestBodyParams struct {\n")
	buf.WriteString("\t\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\tinvalidJSON := `{\"name\": invalid json}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(invalidJSON))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Mock session function\n")
	buf.WriteString("\t\tgetSession := func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test parseRequest with invalid JSON\n")
	buf.WriteString("\t\t_, apiError := " + apiPackageName + ".ParseRequest[any, struct{}, struct{}, TestBodyParams](c, \"test-789\", getSession)\n")
	buf.WriteString("\t\tassert.NotNil(t, apiError, \"Expected API error when JSON is invalid\")\n")
	buf.WriteString("\t\tassert.Equal(t, " + apiPackageName + ".ErrorCodeBadRequest, apiError.Code, \"Should return BadRequest error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"cannot decode json body params\", \"Error message should mention JSON decoding\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-789\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateDecodeBodyParamsTest generates test for decodeBodyParams function.
func generateDecodeBodyParamsTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_decodeBodyParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestBody struct {\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\tAge  int    `json:\"age\"`\n")
	buf.WriteString("\t}\n\n")
	
	buf.WriteString("\ttestBody := `{\"name\": \"test\", \"age\": 25}`\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(testBody))\n")
	buf.WriteString("\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n\n")

	buf.WriteString("\t// Test decodeBodyParams\n")
	buf.WriteString("\tresult, err := " + apiPackageName + ".DecodeBodyParams[TestBody](req)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeBodyParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 25, result.Age, \"Age should be decoded as int\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateDecodePathParamsTest generates test for decodePathParams function.
func generateDecodePathParamsTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_decodePathParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestPathParams struct {\n")
	buf.WriteString("\t\tID   string `json:\"id\"`\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t}\n\n")
	
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\tc.Params = []gin.Param{\n")
	buf.WriteString("\t\t{Key: \"id\", Value: \"123\"},\n")
	buf.WriteString("\t\t{Key: \"name\", Value: \"test\"},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Test decodePathParams\n")
	buf.WriteString("\tresult, err := " + apiPackageName + ".DecodePathParams[TestPathParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodePathParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"123\", result.ID, \"ID should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateDecodeQueryParamsTest generates test for decodeQueryParams function.
func generateDecodeQueryParamsTest(buf *bytes.Buffer, apiPackageName string) error {
	buf.WriteString("func Test_decodeQueryParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestQueryParams struct {\n")
	buf.WriteString("\t\tLimit  int  `form:\"limit\"`\n")
	buf.WriteString("\t\tOffset int  `form:\"offset\"`\n")
	buf.WriteString("\t\tActive bool `form:\"active\"`\n")
	buf.WriteString("\t}\n\n")
	
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\treq, err := http.NewRequest(\"GET\", \"/test?limit=10&offset=0&active=true\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tc.Request = req\n\n")

	buf.WriteString("\t// Test decodeQueryParams\n")
	buf.WriteString("\tresult, err := " + apiPackageName + ".DecodeQueryParams[TestQueryParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeQueryParams\")\n")
	buf.WriteString("\tassert.Equal(t, 10, result.Limit, \"Limit should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 0, result.Offset, \"Offset should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, true, result.Active, \"Active should be decoded\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateInternalEndpointTest generates an internal test function for a specific endpoint.
func generateInternalEndpointTest(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	serviceName := strmangle.TitleCase(service.Name)
	testName := fmt.Sprintf("Test%s%s", resource.Name, endpoint.Name)

	buf.WriteString(fmt.Sprintf("// %s tests the %s endpoint for %s\n", testName, endpoint.Name, resource.Name))
	buf.WriteString(fmt.Sprintf("func %s(t *testing.T) {\n", testName))
	buf.WriteString("\tt.Run(\"Request\", func(t *testing.T) {\n")

	// Generate test setup (without parameters)
	err := generateTestSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate internal mock setup (no package prefixes)
	err = generateInternalMockSetup(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate internal server setup (no package prefixes)
	err = generateInternalServerSetup(buf, serviceName, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate HTTP request (with parameters defined inline)
	err = generateHTTPRequest(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	// Generate internal assertions (no package prefixes)
	err = generateInternalAssertions(buf, service, resource, endpoint)
	if err != nil {
		return err
	}

	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	return nil
}

// generateInternalMockSetup generates internal mock service setup.
func generateInternalMockSetup(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Mock service setup\n")
	buf.WriteString(fmt.Sprintf("\t\tvar capturedRequest Request[any, %s, %s, %s]\n",
		getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
		getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
		getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name))))

	// The mock configuration is now handled in generateInternalServerSetup
	// This function just declares the captured request variable

	return nil
}

// generateInternalServerSetup generates internal HTTP server setup.
func generateInternalServerSetup(buf *bytes.Buffer, serviceName string, service *specification.Service, currentResource specification.Resource, currentEndpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Server setup\n")
	buf.WriteString("\t\trouter := gin.New()\n")

	// Create and configure only the mock for the resource being tested
	buf.WriteString(fmt.Sprintf("\t\tmock%sAPI := &Mock%sAPI{}\n", currentResource.Name, currentResource.Name))

	methodName := currentEndpoint.Name
	if currentEndpoint.HasResponseType() {
		responseType := currentEndpoint.GetResponseType(currentResource.Name)
		buf.WriteString(fmt.Sprintf("\t\texpected%s := &%s{\n", responseType, responseType))
		buf.WriteString("\t\t\t// Add expected response fields here based on your needs\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request Request[any, %s, %s, %s]) (*%s, error) {\n",
			currentResource.Name, methodName,
			getInternalTypeReference(currentEndpoint.GetPathParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name)),
			responseType))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString(fmt.Sprintf("\t\t\treturn expected%s, nil\n", responseType))
		buf.WriteString("\t\t}\n")
	} else {
		buf.WriteString(fmt.Sprintf("\t\tmock%sAPI.%sFunc = func(ctx context.Context, request Request[any, %s, %s, %s]) error {\n",
			currentResource.Name, methodName,
			getInternalTypeReference(currentEndpoint.GetPathParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetQueryParamsType(currentResource.Name)),
			getInternalTypeReference(currentEndpoint.GetBodyParamsType(currentResource.Name))))
		buf.WriteString("\t\t\tcapturedRequest = request\n")
		buf.WriteString("\t\t\treturn nil\n")
		buf.WriteString("\t\t}\n")
	}
	buf.WriteString("\n")

	buf.WriteString(fmt.Sprintf("\t\tRegister%sAPI(router, &%sAPI[any]{\n", serviceName, serviceName))
	buf.WriteString("\t\t\tServer: Server[any]{\n")
	buf.WriteString("\t\t\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\t\t\treturn testSessionUserID, nil\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t\tConvertErrorFunc: func(err error, requestID string) *Error {\n")
	buf.WriteString("\t\t\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t\t\t}\n")
	buf.WriteString("\t\t\t\t},\n")
	buf.WriteString("\t\t\t},\n")

	// Add all resource mocks to the API struct
	for _, resource := range service.Resources {
		if len(resource.Endpoints) > 0 {
			if resource.Name == currentResource.Name {
				// Use the configured mock for the resource being tested
				buf.WriteString(fmt.Sprintf("\t\t\t%s: mock%sAPI,\n", resource.Name, resource.Name))
			} else {
				// Create inline mocks for other resources to prevent panics
				buf.WriteString(fmt.Sprintf("\t\t\t%s: &Mock%sAPI{},\n", resource.Name, resource.Name))
			}
		}
	}

	buf.WriteString("\t\t})\n")
	buf.WriteString("\t\tserver := httptest.NewServer(router)\n")
	buf.WriteString("\t\tdefer server.Close()\n\n")

	return nil
}

// generateInternalAssertions generates internal test assertions.
func generateInternalAssertions(buf *bytes.Buffer, service *specification.Service, resource specification.Resource, endpoint specification.Endpoint) error {
	buf.WriteString("\t\t// Assert\n")
	buf.WriteString("\t\t// Read response body for debugging and verification\n")
	buf.WriteString("\t\tresponseBodyBytes, err := io.ReadAll(resp.Body)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to read response body\")\n\n")

	buf.WriteString("\t\t// Check status code and print response body if unexpected\n")
	buf.WriteString("\t\tif resp.StatusCode != " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + " {\n")
	buf.WriteString("\t\t\tt.Errorf(\"Expected HTTP status %d, got %d. Response body: %s\", " + fmt.Sprintf("%d", endpoint.Response.StatusCode) + ", resp.StatusCode, string(responseBodyBytes))\n")
	buf.WriteString("\t\t\treturn\n")
	buf.WriteString("\t\t}\n\n")

	if endpoint.HasResponseType() {
		buf.WriteString("\t\t// Verify response body\n")
		buf.WriteString("\t\tvar responseBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(responseBodyBytes, &responseBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to decode response body\")\n")
		buf.WriteString("\t\tassert.NotNil(t, responseBody, \"Response body should not be nil\")\n")
	}

	// Verify the service method was called with the request
	buf.WriteString("\t\t// Verify service method was called (indicating HTTP request was processed)\n")
	buf.WriteString("\t\tassert.NotNil(t, capturedRequest, \"Service method should have been called with a request\")\n\n")

	// Add parameter assertions using JSON conversion (same as external tests)
	// Assert path parameters by converting to JSON for easy comparison
	if len(endpoint.Request.PathParams) > 0 {
		buf.WriteString("\t\t// Verify path parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedPathBytes, err := json.Marshal(capturedRequest.PathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured path params\")\n")
		buf.WriteString("\t\tvar capturedPathParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedPathBytes, &capturedPathParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured path params\")\n\n")

		for _, param := range endpoint.Request.PathParams {
			varName := fmt.Sprintf("test%s%s", "Path", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedPathParams[\"%s\"], \"Path parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert query parameters by converting to JSON for easy comparison
	if len(endpoint.Request.QueryParams) > 0 {
		buf.WriteString("\t\t// Verify query parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedQueryBytes, err := json.Marshal(capturedRequest.QueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured query params\")\n")
		buf.WriteString("\t\tvar capturedQueryParams map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedQueryBytes, &capturedQueryParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured query params\")\n\n")

		for _, param := range endpoint.Request.QueryParams {
			varName := fmt.Sprintf("test%s%s", "Query", strmangle.TitleCase(param.Name))
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, %s, capturedQueryParams[\"%s\"], \"Query parameter %s should match\")\n",
				varName, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	// Assert body parameters by converting captured request body to JSON for easy comparison
	if len(endpoint.Request.BodyParams) > 0 {
		buf.WriteString("\t\t// Verify body parameters by converting to JSON\n")
		buf.WriteString("\t\tcapturedBodyBytes, err := json.Marshal(capturedRequest.BodyParams)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to marshal captured body params\")\n")
		buf.WriteString("\t\tvar capturedRequestBody map[string]interface{}\n")
		buf.WriteString("\t\terr = json.Unmarshal(capturedBodyBytes, &capturedRequestBody)\n")
		buf.WriteString("\t\tassert.NoError(t, err, \"Failed to unmarshal captured body params\")\n\n")

		for _, param := range endpoint.Request.BodyParams {
			jsonKey := getJSONKey(param.Name)
			buf.WriteString(fmt.Sprintf("\t\tassert.Equal(t, testBody[\"%s\"], capturedRequestBody[\"%s\"], \"Body parameter %s should match\")\n",
				jsonKey, jsonKey, param.Name))
		}
		buf.WriteString("\n")
	}

	return nil
}

// generateInternalHelperFunctions generates internal helper functions and mock interfaces.
func generateInternalHelperFunctions(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Mock interfaces and helper functions\n")
	buf.WriteString("// ============================================================================\n\n")

	// Generate mock interfaces for each resource (no package prefixes)
	for _, resource := range service.Resources {
		if len(resource.Endpoints) == 0 {
			continue
		}

		buf.WriteString(fmt.Sprintf("// Mock%sAPI is a mock implementation of %sAPI\n", resource.Name, resource.Name))
		buf.WriteString(fmt.Sprintf("type Mock%sAPI struct {\n", resource.Name))

		// Generate function fields for each endpoint (no package prefixes)
		for _, endpoint := range resource.Endpoints {
			methodName := endpoint.Name

			if endpoint.HasResponseType() {
				responseType := endpoint.GetResponseType(resource.Name)
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request Request[any, %s, %s, %s]) (*%s, error)\n",
					methodName,
					getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name)),
					responseType))
			} else {
				buf.WriteString(fmt.Sprintf("\t%sFunc func(ctx context.Context, request Request[any, %s, %s, %s]) error\n",
					methodName,
					getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
					getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name))))
			}
		}

		buf.WriteString("}\n\n")

		// Generate mock methods for each endpoint (no package prefixes)
		for _, endpoint := range resource.Endpoints {
			err := generateInternalMockMethod(buf, resource, endpoint)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

// generateInternalMockMethod generates an internal mock method for an endpoint.
func generateInternalMockMethod(buf *bytes.Buffer, resource specification.Resource, endpoint specification.Endpoint) error {
	methodName := endpoint.Name

	if endpoint.HasResponseType() {
		responseType := endpoint.GetResponseType(resource.Name)
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request Request[any, %s, %s, %s]) (*%s, error) {\n",
			resource.Name, methodName,
			getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name)),
			responseType))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString(fmt.Sprintf("\treturn nil, nil\n"))
	} else {
		buf.WriteString(fmt.Sprintf("func (m *Mock%sAPI) %s(ctx context.Context, request Request[any, %s, %s, %s]) error {\n",
			resource.Name, methodName,
			getInternalTypeReference(endpoint.GetPathParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetQueryParamsType(resource.Name)),
			getInternalTypeReference(endpoint.GetBodyParamsType(resource.Name))))
		buf.WriteString(fmt.Sprintf("\tif m.%sFunc != nil {\n", methodName))
		buf.WriteString(fmt.Sprintf("\t\treturn m.%sFunc(ctx, request)\n", methodName))
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil\n")
	}

	buf.WriteString("}\n\n")

	return nil
}

// generateInternalUtilityTests generates internal tests for utility functions.
func generateInternalUtilityTests(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString("// ============================================================================\n")
	buf.WriteString("// Utility function tests\n")
	buf.WriteString("// ============================================================================\n\n")

	// Test serveWithResponse (no package prefixes)
	buf.WriteString("func Test_serveWithResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that returns a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request Request[any, struct{}, struct{}, struct{}]) (*map[string]interface{}, error) {\n")
	buf.WriteString("\t\treturn &map[string]interface{}{\"message\": \"success\"}, nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tConvertErrorFunc: func(err error, requestID string) *Error {\n")
	buf.WriteString("\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithResponse\n")
	buf.WriteString("\thandler := serveWithResponse(200, server, mockFunction)\n")
	buf.WriteString("\trouter.POST(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 200, w.Code, \"Expected 200 status code\")\n")
	buf.WriteString("\tassert.Contains(t, w.Body.String(), \"success\", \"Expected success message\")\n")
	buf.WriteString("}\n\n")

	// Test serveWithoutResponse
	buf.WriteString("func Test_serveWithoutResponse(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\trouter := gin.New()\n\n")

	buf.WriteString("\t// Mock function that doesn't return a response\n")
	buf.WriteString("\tmockFunction := func(ctx context.Context, request Request[any, struct{}, struct{}, struct{}]) error {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create server configuration\n")
	buf.WriteString("\tserver := Server[any]{\n")
	buf.WriteString("\t\tGetSessionFunc: func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t\tConvertErrorFunc: func(err error, requestID string) *Error {\n")
	buf.WriteString("\t\t\treturn &Error{\n")
	buf.WriteString("\t\t\t\tCode:      ErrorCodeInternal,\n")
	buf.WriteString("\t\t\t\tMessage:   types.NewString(err.Error()),\n")
	buf.WriteString("\t\t\t\tRequestID: types.NewString(requestID),\n")
	buf.WriteString("\t\t\t}\n")
	buf.WriteString("\t\t},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Create handler using serveWithoutResponse\n")
	buf.WriteString("\thandler := serveWithoutResponse(204, server, mockFunction)\n")
	buf.WriteString("\trouter.DELETE(\"/test\", handler)\n\n")

	buf.WriteString("\t// Create test request\n")
	buf.WriteString("\treq, err := http.NewRequest(\"DELETE\", \"/test\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tw := httptest.NewRecorder()\n")
	buf.WriteString("\trouter.ServeHTTP(w, req)\n\n")

	buf.WriteString("\t// Assert response\n")
	buf.WriteString("\tassert.Equal(t, 204, w.Code, \"Expected 204 status code\")\n")
	buf.WriteString("}\n\n")

	// Test parseRequest
	buf.WriteString("func Test_parseRequest(t *testing.T) {\n")
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n\n")

	buf.WriteString("\tt.Run(\"successful request parsing\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n\n")

	buf.WriteString("\t\t// Create test request with JSON body\n")
	buf.WriteString("\t\ttestBody := `{\"name\": \"test\"}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test?limit=10&offset=0\", strings.NewReader(testBody))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n")
	buf.WriteString("\t\tc.Params = []gin.Param{{Key: \"id\", Value: \"123\"}}\n\n")

	buf.WriteString("\t\t// Mock session function\n")
	buf.WriteString("\t\tgetSession := func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test parseRequest\n")
	buf.WriteString("\t\trequest, apiError := parseRequest[any, struct{}, struct{}, struct{}](c, \"test-123\", getSession)\n")
	buf.WriteString("\t\tassert.Nil(t, apiError, \"Expected no error from parseRequest\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-session\", request.Session, \"Session should be set\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-123\", request.RequestID(), \"RequestID should be set\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"session function error returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", nil)\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Mock session function that returns error\n")
	buf.WriteString("\t\tgetSessionWithError := func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn nil, fmt.Errorf(\"authentication failed\")\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test parseRequest with session error\n")
	buf.WriteString("\t\t_, apiError := parseRequest[any, struct{}, struct{}, struct{}](c, \"test-456\", getSessionWithError)\n")
	buf.WriteString("\t\tassert.NotNil(t, apiError, \"Expected API error when session function fails\")\n")
	buf.WriteString("\t\tassert.Equal(t, ErrorCodeUnauthorized, apiError.Code, \"Should return Unauthorized error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"authentication failed\", \"Error message should contain session error\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-456\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n\n")

	buf.WriteString("\tt.Run(\"invalid JSON body returns API error\", func(t *testing.T) {\n")
	buf.WriteString("\t\t// Define test struct for body params\n")
	buf.WriteString("\t\ttype TestBodyParams struct {\n")
	buf.WriteString("\t\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\t\tinvalidJSON := `{\"name\": invalid json}`\n")
	buf.WriteString("\t\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(invalidJSON))\n")
	buf.WriteString("\t\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\t\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\t\tc.Request = req\n\n")

	buf.WriteString("\t\t// Mock session function\n")
	buf.WriteString("\t\tgetSession := func(ctx context.Context, headers http.Header, requestID string) (any, error) {\n")
	buf.WriteString("\t\t\treturn \"test-session\", nil\n")
	buf.WriteString("\t\t}\n\n")

	buf.WriteString("\t\t// Test parseRequest with invalid JSON\n")
	buf.WriteString("\t\t_, apiError := parseRequest[any, struct{}, struct{}, TestBodyParams](c, \"test-789\", getSession)\n")
	buf.WriteString("\t\tassert.NotNil(t, apiError, \"Expected API error when JSON is invalid\")\n")
	buf.WriteString("\t\tassert.Equal(t, ErrorCodeBadRequest, apiError.Code, \"Should return BadRequest error code\")\n")
	buf.WriteString("\t\tassert.Contains(t, apiError.Message.String(), \"cannot decode json body params\", \"Error message should mention JSON decoding\")\n")
	buf.WriteString("\t\tassert.Equal(t, \"test-789\", apiError.RequestID.String(), \"Request ID should be set in error\")\n")
	buf.WriteString("\t})\n")
	buf.WriteString("}\n\n")

	// Test decodeBodyParams
	buf.WriteString("func Test_decodeBodyParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestBody struct {\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t\tAge  int    `json:\"age\"`\n")
	buf.WriteString("\t}\n\n")
	
	buf.WriteString("\ttestBody := `{\"name\": \"test\", \"age\": 25}`\n")
	buf.WriteString("\treq, err := http.NewRequest(\"POST\", \"/test\", strings.NewReader(testBody))\n")
	buf.WriteString("\treq.Header.Set(\"Content-Type\", \"application/json\")\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n\n")

	buf.WriteString("\t// Test decodeBodyParams\n")
	buf.WriteString("\tresult, err := decodeBodyParams[TestBody](req)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeBodyParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 25, result.Age, \"Age should be decoded as int\")\n")
	buf.WriteString("}\n\n")

	// Test decodePathParams
	buf.WriteString("func Test_decodePathParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestPathParams struct {\n")
	buf.WriteString("\t\tID   string `json:\"id\"`\n")
	buf.WriteString("\t\tName string `json:\"name\"`\n")
	buf.WriteString("\t}\n\n")
	
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\tc.Params = []gin.Param{\n")
	buf.WriteString("\t\t{Key: \"id\", Value: \"123\"},\n")
	buf.WriteString("\t\t{Key: \"name\", Value: \"test\"},\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\t// Test decodePathParams\n")
	buf.WriteString("\tresult, err := decodePathParams[TestPathParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodePathParams\")\n")
	buf.WriteString("\tassert.Equal(t, \"123\", result.ID, \"ID should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, \"test\", result.Name, \"Name should be decoded\")\n")
	buf.WriteString("}\n\n")

	// Test decodeQueryParams
	buf.WriteString("func Test_decodeQueryParams(t *testing.T) {\n")
	buf.WriteString("\t// Define test struct\n")
	buf.WriteString("\ttype TestQueryParams struct {\n")
	buf.WriteString("\t\tLimit  int  `form:\"limit\"`\n")
	buf.WriteString("\t\tOffset int  `form:\"offset\"`\n")
	buf.WriteString("\t\tActive bool `form:\"active\"`\n")
	buf.WriteString("\t}\n\n")
	
	buf.WriteString("\tgin.SetMode(gin.TestMode)\n")
	buf.WriteString("\tc, _ := gin.CreateTestContext(httptest.NewRecorder())\n")
	buf.WriteString("\treq, err := http.NewRequest(\"GET\", \"/test?limit=10&offset=0&active=true\", nil)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Failed to create request\")\n")
	buf.WriteString("\tc.Request = req\n\n")

	buf.WriteString("\t// Test decodeQueryParams\n")
	buf.WriteString("\tresult, err := decodeQueryParams[TestQueryParams](c)\n")
	buf.WriteString("\tassert.NoError(t, err, \"Expected no error from decodeQueryParams\")\n")
	buf.WriteString("\tassert.Equal(t, 10, result.Limit, \"Limit should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, 0, result.Offset, \"Offset should be decoded\")\n")
	buf.WriteString("\tassert.Equal(t, true, result.Active, \"Active should be decoded\")\n")
	buf.WriteString("}\n\n")

	return nil
}

// getInternalTypeReference returns type names without package prefixes for internal tests.
func getInternalTypeReference(typeName string) string {
	return typeName // No package prefix needed for internal tests
}

// getJSONKey converts a field name to its JSON key (camelCase).
func getJSONKey(fieldName string) string {
	return specification.CamelCase(fieldName)
}
