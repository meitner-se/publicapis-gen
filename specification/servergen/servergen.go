package servergen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/aarondl/strmangle"
	"github.com/meitner-se/publicapis-gen/specification"
)

const (
	disclaimerComment = "// Code generated by publicapis-gen servergen. DO NOT EDIT.\n// This file is automatically generated from the API specification.\n// Any changes made to this file will be overwritten on the next generation.\n\n"
)

// convertOpenAPIPathToGin converts OpenAPI-style path parameters {param} to Gin-style :param
func convertOpenAPIPathToGin(path string) string {
	// Convert {param} to :param for Gin router
	result := path
	for {
		start := strings.Index(result, "{")
		if start == -1 {
			break
		}
		end := strings.Index(result[start:], "}")
		if end == -1 {
			break
		}
		end += start

		// Extract parameter name
		paramName := result[start+1 : end]

		// Replace {param} with :param
		result = result[:start] + ":" + paramName + result[end+1:]
	}
	return result
}

func GenerateServer(buf *bytes.Buffer, service *specification.Service) error {
	buf.WriteString(disclaimerComment)
	buf.WriteString("package api\n\n")

	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"embed\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"strings\"\n\n")
	buf.WriteString(fmt.Sprintf("\t\"%s\"\n", "github.com/google/uuid"))
	buf.WriteString(fmt.Sprintf("\t\"%s\"\n", "github.com/gin-gonic/gin"))
	buf.WriteString(fmt.Sprintf("\t\"%s\"\n", "github.com/meitner-se/go-types"))
	buf.WriteString(")\n\n")

	err := generateServer(buf, service)
	if err != nil {
		return err
	}

	err = generateEnums(buf, service.Enums)
	if err != nil {
		return err
	}

	err = generateObjects(buf, service)
	if err != nil {
		return err
	}

	err = generateRequestTypes(buf, service)
	if err != nil {
		return err
	}

	err = generateResponseTypes(buf, service)
	if err != nil {
		return err
	}

	err = generateUtils(buf)
	if err != nil {
		return err
	}

	// Format the buffer content
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("gofmt failed: %w", err)
	}

	// Write the formatted content back to the buffer
	buf.Reset()
	buf.Write(formatted)

	return nil
}

func generateEnums(buf *bytes.Buffer, enums []specification.Enum) error {
	for _, enumStruct := range enums {
		buf.WriteString("var (\n")
		for _, value := range enumStruct.Values {
			buf.WriteString(fmt.Sprintf("\t%s%s = types.NewString(\"%s\") // %s\n", enumStruct.Name, value.Name, value.Name, value.Description))
		}
		buf.WriteString(")\n\n")
	}

	return nil
}

func getTypeForGo(field specification.Field, service *specification.Service) string {
	fieldType := field.Type

	if service.HasEnum(fieldType) {
		fieldType = "String"
	}

	return getTypePrefix(field, service) + fieldType
}

// getTypeForGoFilter generates Go type for fields in filter objects with special pointer handling.
func getTypeForGoFilter(field specification.Field, service *specification.Service, parentObject specification.Object) string {
	fieldType := field.Type

	if service.HasEnum(fieldType) {
		fieldType = "String"
	}

	return getTypePrefixForFilter(field, service, parentObject) + fieldType
}

func getTypePrefix(field specification.Field, service *specification.Service) string {
	isObject := service.IsObject(field.Type)

	prefixes := []string{}

	if field.IsArray() {
		prefixes = append(prefixes, "[]")
	}

	// Note: Removed pointer prefix for nullable objects as per INF-407
	// if field.IsNullable() && isObject {
	//     prefixes = append(prefixes, "*")
	// }

	if !isObject {
		prefixes = append(prefixes, "types.")
	}

	typePrefix := strings.Join(prefixes, "")

	return typePrefix
}

// getTypePrefixForFilter handles filter objects specifically.
// Filter type fields (Equals, NotEquals, etc.) should be pointers.
// Nested filter object fields should NOT be pointers.
func getTypePrefixForFilter(field specification.Field, service *specification.Service, parentObject specification.Object) string {
	isObject := service.IsObject(field.Type)

	prefixes := []string{}

	if field.IsArray() {
		prefixes = append(prefixes, "[]")
	}

	// Special logic for filter objects
	if parentObject.IsFilter() {
		// Check if this is a filter type field (Equals, NotEquals, etc.)
		if isFilterTypeField(field.Name) && field.IsNullable() && isObject {
			prefixes = append(prefixes, "*")
		}
		// For nested filter object fields (like Meta, External), don't add pointer
		// even if they're nullable - this follows the user's requirement
	}

	if !isObject {
		prefixes = append(prefixes, "types.")
	}

	typePrefix := strings.Join(prefixes, "")

	return typePrefix
}

// isFilterTypeField checks if a field name is one of the standard filter type fields.
func isFilterTypeField(fieldName string) bool {
	filterFields := []string{
		"Equals", "NotEquals", "GreaterThan", "SmallerThan",
		"GreaterOrEqual", "SmallerOrEqual", "Contains", "NotContains",
		"Like", "NotLike", "Null", "NotNull",
	}

	for _, filterField := range filterFields {
		if fieldName == filterField {
			return true
		}
	}
	return false
}

func generateObjects(buf *bytes.Buffer, service *specification.Service) error {
	for _, object := range service.Objects {
		buf.WriteString(fmt.Sprintf("%s\n", object.GetComment()))
		buf.WriteString(fmt.Sprintf("type %s struct {\n", object.Name))

		for _, field := range object.Fields {
			buf.WriteString(fmt.Sprintf("%s\n", field.GetComment("\t")))

			// Use filter-aware type generation for filter objects
			var fieldType string
			if object.IsFilter() {
				fieldType = getTypeForGoFilter(field, service, object)
			} else {
				fieldType = getTypeForGo(field, service)
			}

			buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n\n", field.Name, fieldType, field.TagJSON()))
		}

		buf.WriteString("}\n\n")

		if object.Name == "Error" {
			buf.WriteString("func (e *Error) Error() string {\n")
			buf.WriteString("\treturn e.Message.String()\n")
			buf.WriteString("}\n\n")

			buf.WriteString("func (e *Error) HTTPStatusCode() int {\n")
			buf.WriteString("\tswitch e.Code {\n")
			buf.WriteString("\tcase ErrorCodeBadRequest:\n")
			buf.WriteString("\t\treturn http.StatusBadRequest\n")
			buf.WriteString("\tcase ErrorCodeUnauthorized:\n")
			buf.WriteString("\t\treturn http.StatusUnauthorized\n")
			buf.WriteString("\tcase ErrorCodeForbidden:\n")
			buf.WriteString("\t\treturn http.StatusForbidden\n")
			buf.WriteString("\tcase ErrorCodeNotFound:\n")
			buf.WriteString("\t\treturn http.StatusNotFound\n")
			buf.WriteString("\tcase ErrorCodeConflict:\n")
			buf.WriteString("\t\treturn http.StatusConflict\n")
			buf.WriteString("\tcase ErrorCodeUnprocessableEntity:\n")
			buf.WriteString("\t\treturn http.StatusUnprocessableEntity\n")
			buf.WriteString("\tcase ErrorCodeRateLimited:\n")
			buf.WriteString("\t\treturn http.StatusTooManyRequests\n")
			buf.WriteString("\tcase ErrorCodeInternal:\n")
			buf.WriteString("\t\treturn http.StatusInternalServerError\n")
			buf.WriteString("\tdefault:\n")
			buf.WriteString("\t\treturn http.StatusInternalServerError\n")
			buf.WriteString("\t}\n")
			buf.WriteString("}\n\n")
		}
	}

	return nil
}

func generateServer(buf *bytes.Buffer, service *specification.Service) error {
	serviceName := strmangle.TitleCase(service.Name)
	buf.WriteString(fmt.Sprintf("func Register%sAPI[Session any](router *gin.Engine, api *%sAPI[Session]) {\n", serviceName, serviceName))
	buf.WriteString("\tif api.Server.ErrorHook == nil {\n")
	buf.WriteString("\t\tapi.Server.ErrorHook = defaultErrorHook\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tif api.Server.GetSessionFunc == nil {\n")
	buf.WriteString("\t\tpanic(\"GetSessionFunc is nil\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tif api.Server.GetRequestIDFunc == nil {\n")
	buf.WriteString("\t\tapi.Server.GetRequestIDFunc = func(_ context.Context) string {\n")
	buf.WriteString("\t\t\treturn uuid.New().String()\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString(fmt.Sprintf("\trouterGroup := router.Group(\"/%s/%s\")\n\n", service.PathName(), service.Version))

	buf.WriteString("\t// OpenAPI Documentation in JSON format\n")
	buf.WriteString("\trouterGroup.StaticFileFS(\"/openapi.json\", \"openapi.json\", http.FS(api.OpenAPI_JSON))\n\n")

	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			if endpoint.HasResponseType() {
				buf.WriteString(fmt.Sprintf("\trouterGroup.%s(\"%s\", serveWithResponse(%d, api.Server, api.%s.%s))\n",
					endpoint.Method,
					convertOpenAPIPathToGin(endpoint.GetFullPath(resource.Name)),
					endpoint.Response.StatusCode,
					resource.Name,
					endpoint.Name,
				))
			} else {
				buf.WriteString(fmt.Sprintf("\trouterGroup.%s(\"%s\", serveWithoutResponse(%d, api.Server, api.%s.%s))\n",
					endpoint.Method,
					convertOpenAPIPathToGin(endpoint.GetFullPath(resource.Name)),
					endpoint.Response.StatusCode,
					resource.Name,
					endpoint.Name,
				))
			}
		}
		buf.WriteString("\n")
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// getSessionFunc is a function that is used on each endpoint to set the session to the request\n")
	buf.WriteString("type getSessionFunc[T any] func(ctx context.Context, headers http.Header) (T, error)\n\n")

	buf.WriteString(fmt.Sprintf("type %sAPI[Session any] struct {\n", serviceName))
	buf.WriteString("\t// Server is the server configuration for the API\n")
	buf.WriteString("\tServer Server[Session]\n")

	buf.WriteString("\tOpenAPI_JSON embed.FS\n")
	for _, resource := range service.Resources {
		buf.WriteString(fmt.Sprintf("\t%s %sAPI[Session] // Endpoints for the %s resource\n", resource.Name, resource.Name, resource.Name))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("type Server[Session any] struct {\n")
	buf.WriteString("\t// GetRequestIDFunc is a function that generates a request ID for each request\n")
	buf.WriteString("\t// If nil, a default UUID-based request ID generator will be used\n")
	buf.WriteString("\tGetRequestIDFunc func(ctx context.Context) string\n")

	buf.WriteString("\t// GetSessionFunc is a function that is used on each endpoint to set the session to the request\n")
	buf.WriteString("\tGetSessionFunc getSessionFunc[Session]\n")

	buf.WriteString("\t// ErrorHook is a function that is used on each endpoint to convert an error to an Error object\n")
	buf.WriteString("\tErrorHook func(err error, requestID string) *Error\n")

	buf.WriteString("\t// PreHooks are executed before endpoint logic. The first non-nil error aborts request processing.\n")
	buf.WriteString("\tPreHooks []PreHook\n")

	buf.WriteString("\t// SessionHooks are executed after authentication. The first non-nil error aborts request processing.\n")
	buf.WriteString("\t// Example usages:\n")
	buf.WriteString("\t//   - Logging: Log authenticated requests with user information from the session\n")
	buf.WriteString("\t//   - Rate Limiting: Check if the user has exceeded their API rate limit based on session data\n")
	buf.WriteString("\t//   - Authorization: Verify the user has permission to access the requested resource\n")
	buf.WriteString("\t// \n")
	buf.WriteString("\t// Example implementation:\n")
	buf.WriteString("\t//   SessionHooks: []SessionHook[MySession]{\n")
	buf.WriteString("\t//     // Logging hook\n")
	buf.WriteString("\t//     func(ctx context.Context, reqCtx RequestContext, session MySession) error {\n")
	buf.WriteString("\t//       log.Printf(\"User %s accessed %s %s\", session.UserID, reqCtx.HTTPMethod, reqCtx.Path)\n")
	buf.WriteString("\t//       return nil\n")
	buf.WriteString("\t//     },\n")
	buf.WriteString("\t//     // Rate limiting hook\n")
	buf.WriteString("\t//     func(ctx context.Context, reqCtx RequestContext, session MySession) error {\n")
	buf.WriteString("\t//       if rateLimiter.IsExceeded(session.UserID) {\n")
	buf.WriteString("\t//         return errors.New(\"rate limit exceeded\")\n")
	buf.WriteString("\t//       }\n")
	buf.WriteString("\t//       return nil\n")
	buf.WriteString("\t//     },\n")
	buf.WriteString("\t//     // Authorization hook\n")
	buf.WriteString("\t//     func(ctx context.Context, reqCtx RequestContext, session MySession) error {\n")
	buf.WriteString("\t//       if !session.HasPermission(reqCtx.Route) {\n")
	buf.WriteString("\t//         return errors.New(\"insufficient permissions\")\n")
	buf.WriteString("\t//       }\n")
	buf.WriteString("\t//       return nil\n")
	buf.WriteString("\t//     },\n")
	buf.WriteString("\t//   },\n")
	buf.WriteString("\tSessionHooks []SessionHook[Session]\n")
	buf.WriteString("}\n\n")

	for _, resource := range service.Resources {
		buf.WriteString(fmt.Sprintf("type %sAPI[Session any] interface {\n", resource.Name))
		for _, endpoint := range resource.Endpoints {
			if endpoint.HasResponseType() {
				buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, request Request[Session, %s, %s, %s]) (*%s, error)\n",
					endpoint.Name,
					endpoint.GetPathParamsType(resource.Name),
					endpoint.GetQueryParamsType(resource.Name),
					endpoint.GetBodyParamsType(resource.Name),
					endpoint.GetResponseType(resource.Name),
				))
			} else {
				buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, request Request[Session, %s, %s, %s]) error\n",
					endpoint.Name,
					endpoint.GetPathParamsType(resource.Name),
					endpoint.GetQueryParamsType(resource.Name),
					endpoint.GetBodyParamsType(resource.Name),
				))
			}
		}
		buf.WriteString("}\n\n")
	}

	return nil
}

func generateRequestTypes(buf *bytes.Buffer, service *specification.Service) error {
	// Generate PreHook types first
	buf.WriteString("// PreHook runs before endpoint logic. Return nil to continue; non-nil to abort.\n")
	buf.WriteString("type PreHook func(ctx context.Context, requestContext RequestContext) error\n\n")

	buf.WriteString("// PreHooks is an optional helper type if you prefer a named slice.\n")
	buf.WriteString("type PreHooks []PreHook\n\n")

	// Generate SessionHook types
	buf.WriteString("// SessionHook runs after authentication. Return nil to continue; non-nil to abort.\n")
	buf.WriteString("// SessionHooks have access to both the RequestContext and the authenticated Session,\n")
	buf.WriteString("// enabling use cases such as:\n")
	buf.WriteString("//   - Logging authenticated requests with session/user information\n")
	buf.WriteString("//   - Rate limiting based on user or tenant from the session\n")
	buf.WriteString("//   - Authorization checks to verify the user can access the requested resource\n")
	buf.WriteString("//   - Metrics collection for authenticated API usage\n")
	buf.WriteString("//   - Session validation or enrichment\n")
	buf.WriteString("type SessionHook[Session any] func(ctx context.Context, requestContext RequestContext, session Session) error\n\n")

	buf.WriteString("// SessionHooks is an optional helper type if you prefer a named slice.\n")
	buf.WriteString("type SessionHooks[Session any] []SessionHook[Session]\n\n")

	// Generate RequestContext struct
	buf.WriteString("type RequestContext struct {\n")
	buf.WriteString("\t// ID of the request, can be used for debugging.\n")
	buf.WriteString("\tRequestID string `json:\"requestId\"`\n\n")
	buf.WriteString("\t// Path of the request. For example, /employee/123/archive\n")
	buf.WriteString("\tPath string `json:\"path\"`\n\n")
	buf.WriteString("\t// Route of the request. For example, /employee/:employee_id/archive\n")
	buf.WriteString("\tRoute string `json:\"route\"`\n\n")
	buf.WriteString("\t// UserAgent of the request\n")
	buf.WriteString("\tUserAgent string `json:\"userAgent\"`\n\n")
	buf.WriteString("\t// HTTPMethod of the request. For example, POST\n")
	buf.WriteString("\tHTTPMethod string `json:\"httpMethod\"`\n\n")
	buf.WriteString("\t// IPAddress of the request.\n")
	buf.WriteString("\tIPAddress string `json:\"ipAddress\"`\n")
	buf.WriteString("}\n\n")

	// Generate Request struct
	buf.WriteString("type Request[sessionType, pathParamsType, queryParamsType, bodyParamsType any] struct {\n")
	buf.WriteString("\trequestContext RequestContext `json:\"-\"` // Unexported field\n")
	buf.WriteString("\tSession sessionType `json:\"-\"`\n")
	buf.WriteString("\tPathParams pathParamsType `json:\"-\"`\n")
	buf.WriteString("\tQueryParams queryParamsType `json:\"-\"`\n")
	buf.WriteString("\tBodyParams bodyParamsType `json:\"-\"`\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func (r Request[sessionType, pathParamsType, queryParamsType, bodyParamsType]) Context() RequestContext {\n")
	buf.WriteString("\treturn r.requestContext\n")
	buf.WriteString("}\n\n")

	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			if len(endpoint.Request.PathParams) > 0 {
				buf.WriteString(fmt.Sprintf("type %s struct {\n", endpoint.GetPathParamsType(resource.Name)))
				for _, field := range endpoint.Request.PathParams {
					buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", field.Name, getTypeForGo(field, service), field.TagJSON()))
				}
				buf.WriteString("}\n\n")
			}

			if len(endpoint.Request.QueryParams) > 0 {
				buf.WriteString(fmt.Sprintf("type %s struct {\n", endpoint.GetQueryParamsType(resource.Name)))
				for _, field := range endpoint.Request.QueryParams {
					buf.WriteString(fmt.Sprintf("\t%s %s `form:\"%s\" json:\"%s\"`\n", field.Name, getTypeForGo(field, service), field.TagJSON(), field.TagJSON()))
				}
				buf.WriteString("}\n\n")
			}

			if len(endpoint.Request.BodyParams) > 0 {
				buf.WriteString(fmt.Sprintf("type %s struct {\n", endpoint.GetBodyParamsType(resource.Name)))
				for _, field := range endpoint.Request.BodyParams {
					buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", field.Name, getTypeForGo(field, service), field.TagJSON()))
				}
				buf.WriteString("}\n\n")
			}
		}
	}

	return nil
}

func generateResponseTypes(buf *bytes.Buffer, service *specification.Service) error {
	for _, resource := range service.Resources {
		for _, endpoint := range resource.Endpoints {
			if len(endpoint.Response.BodyFields) == 0 {
				continue
			}

			buf.WriteString(fmt.Sprintf("type %s struct {\n", endpoint.GetResponseType(resource.Name)))
			for _, field := range endpoint.Response.BodyFields {
				buf.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", field.Name, getTypeForGo(field, service), field.TagJSON()))
			}
			buf.WriteString("}\n\n")
		}
	}

	return nil
}

func generateUtils(buf *bytes.Buffer) error {
	// Generate error types for classification
	buf.WriteString(`// Common error types that can be used with ErrorHook
type (
	// AuthenticationError indicates authentication failure
	AuthenticationError struct {
		error
	}

	// ValidationError indicates input validation failure
	ValidationError struct {
		error
	}

	// DecodingError indicates parameter decoding failure
	DecodingError struct {
		error
	}
)

// WrapAuthenticationError wraps an error as an authentication error
func WrapAuthenticationError(err error) error {
	return AuthenticationError{err}
}

// WrapValidationError wraps an error as a validation error
func WrapValidationError(err error) error {
	return ValidationError{err}
}

// WrapDecodingError wraps an error as a decoding error
func WrapDecodingError(err error) error {
	return DecodingError{err}
}

// defaultErrorHook is the default error conversion function
func defaultErrorHook(err error, requestID string) *Error {
	// Check for wrapped error types
	switch err.(type) {
	case AuthenticationError:
		return &Error{
			Code:      ErrorCodeUnauthorized,
			Message:   types.NewString(err.Error()),
			RequestID: types.NewString(requestID),
		}
	case ValidationError, DecodingError:
		return &Error{
			Code:      ErrorCodeBadRequest,
			Message:   types.NewString(err.Error()),
			RequestID: types.NewString(requestID),
		}
	default:
		// Check for common error patterns in error messages
		errMsg := err.Error()
		if strings.Contains(errMsg, "cannot decode") || strings.Contains(errMsg, "json:") || strings.Contains(errMsg, "invalid") {
			return &Error{
				Code:      ErrorCodeBadRequest,
				Message:   types.NewString(errMsg),
				RequestID: types.NewString(requestID),
			}
		}
		
		// Default to internal error
		return &Error{
			Code:      ErrorCodeInternal,
			Message:   types.NewString(errMsg),
			RequestID: types.NewString(requestID),
		}
	}
}
` + "\n")

	buf.WriteString(`func serveWithResponse[
	sessionType any,
	pathParamsType any,
	queryParamsType any,
	bodyParamsType any,
	responseType any,
](
	successStatusCode int,
	server Server[sessionType],
	function func(ctx context.Context, request Request[sessionType, pathParamsType, queryParamsType, bodyParamsType]) (*responseType, error),
) gin.HandlerFunc {
	return func(c *gin.Context) {
		requestID := server.GetRequestIDFunc(c.Request.Context())

		request, apiError := handleRequest[sessionType, pathParamsType, queryParamsType, bodyParamsType](c, requestID, server)
		if apiError != nil {
			c.JSON(apiError.HTTPStatusCode(), apiError)
			return
		}

		response, err := function(c.Request.Context(), request)
		if err != nil {
			apiError := server.ErrorHook(err, requestID)
			c.JSON(apiError.HTTPStatusCode(), apiError)
			return
		}

		c.JSON(successStatusCode, response)
	}
}` + "\n\n")

	buf.WriteString(`func serveWithoutResponse[
	sessionType any,
	pathParamsType any,
	queryParamsType any,
	bodyParamsType any,
](
	successStatusCode int,
	server Server[sessionType],
	function func(ctx context.Context, request Request[sessionType, pathParamsType, queryParamsType, bodyParamsType]) error,
) gin.HandlerFunc {
	return func(c *gin.Context) {
		requestID := server.GetRequestIDFunc(c.Request.Context())

		request, apiError := handleRequest[sessionType, pathParamsType, queryParamsType, bodyParamsType](c, requestID, server)
		if apiError != nil {
			c.JSON(apiError.HTTPStatusCode(), apiError)
			return
		}

		err := function(c.Request.Context(), request)
		if err != nil {
			apiError := server.ErrorHook(err, requestID)
			c.JSON(apiError.HTTPStatusCode(), apiError)
			return
		}
		
		c.JSON(successStatusCode, nil)
	}
}` + "\n\n")

	buf.WriteString(`func handleRequest[
	sessionType any,
	pathParamsType any,
	queryParamsType any,
	bodyParamsType any,
](
	c *gin.Context,
	requestID string,
	server Server[sessionType],
) (Request[sessionType, pathParamsType, queryParamsType, bodyParamsType], *Error) {
	var nilRequest Request[sessionType, pathParamsType, queryParamsType, bodyParamsType]

	// Build RequestContext first for pre-hooks
	requestContext := RequestContext{
		RequestID:  requestID,
		Path:       c.Request.URL.Path,
		Route:      c.FullPath(),
		UserAgent:  c.Request.UserAgent(),
		HTTPMethod: c.Request.Method,
		IPAddress:  c.ClientIP(),
	}

	// Run pre-hooks before parsing request
	for _, preHook := range server.PreHooks {
		if err := preHook(c.Request.Context(), requestContext); err != nil {
			apiError := server.ErrorHook(err, requestID)
			return nilRequest, apiError
		}
	}

	session, err := server.GetSessionFunc(c.Request.Context(), c.Request.Header)
	if err != nil {
		apiError := server.ErrorHook(WrapAuthenticationError(err), requestID)
		return nilRequest, apiError
	}

	// Run session hooks after successful authentication
	// These hooks can perform logging, rate limiting, authorization checks, etc.
	// The hooks are executed in the order they are defined in the SessionHooks slice
	for _, sessionHook := range server.SessionHooks {
		if err := sessionHook(c.Request.Context(), requestContext, session); err != nil {
			apiError := server.ErrorHook(err, requestID)
			return nilRequest, apiError
		}
	}

	request := Request[sessionType, pathParamsType, queryParamsType, bodyParamsType]{
		requestContext: requestContext,
		Session: session,
	}

	if _, ok := any(request.BodyParams).(struct{}); !ok {
		bodyParams, err := decodeBodyParams[bodyParamsType](c.Request)
		if err != nil {
			apiError := server.ErrorHook(WrapDecodingError(fmt.Errorf("cannot decode json body params: %w", err)), requestID)
			return nilRequest, apiError
		}

		request.BodyParams = bodyParams
	}

	if _, ok := any(request.PathParams).(struct{}); !ok {
		pathParams, err := decodePathParams[pathParamsType](c)
		if err != nil {
			apiError := server.ErrorHook(WrapDecodingError(fmt.Errorf("cannot decode path params: %w", err)), requestID)
			return nilRequest, apiError
		}

		request.PathParams = pathParams
	}

	if _, ok := any(request.QueryParams).(struct{}); !ok {
		queryParams, err := decodeQueryParams[queryParamsType](c)
		if err != nil {
			apiError := server.ErrorHook(WrapDecodingError(fmt.Errorf("cannot decode query params: %w", err)), requestID)
			return nilRequest, apiError
		}

		request.QueryParams = queryParams
	}

	return request, nil
}` + "\n\n")

	buf.WriteString(`func decodeBodyParams[T any](r *http.Request) (T, error) {
	var v T

	if err := json.NewDecoder(r.Body).Decode(&v); err != nil {
		return v, err
	}

	return v, nil
}` + "\n\n")

	buf.WriteString(`func decodePathParams[T any](c *gin.Context) (T, error) {
	var result T

	m := make(map[string]string, len(c.Params))
	for _, p := range c.Params {
		m[p.Key] = p.Value
	}

	data, err := json.Marshal(m)
	if err != nil {
		return result, err
	}

	if err := json.Unmarshal(data, &result); err != nil {
		return result, err
	}

	return result, nil
}` + "\n\n")

	buf.WriteString(`// decodeQueryParams decodes the query parameters from the request into the given type,
// it can be limit & offset keys for example and they should be parsed into the correct type
func decodeQueryParams[T any](c *gin.Context) (T, error) {
	var result T

	if err := c.ShouldBindQuery(&result); err != nil {
		return result, err
	}

	return result, nil
}` + "\n")

	return nil
}
